(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{dfDs:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return l}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var r=t("7ljp"),a=t("Hv6d");var s={},c={_frontmatter:s},o=a.a;function l(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(r.b)(o,Object.assign({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",null,"前言"),Object(r.b)("p",null,"axios可作为前后端通信的桥梁,十分重要,同样也是面试高频。\n但实际上,axios的功能点拆分来看,并不是很多。主要分为适配器,拦截器,请求发送,请求取消四大部分。\n本篇为源码系列核心实现第二篇,对应下图axios部分。"),Object(r.b)("p",null,Object(r.b)("img",Object.assign({parentName:"p"},{src:"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png",alt:"src"}))),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null})),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null})))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"name"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"desc")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"adapter"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"根据宿主环境适配请求方式")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"interceptor"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"请求拦截器,响应拦截器")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"request"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"发起请求")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"cancel token"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"取消请求")))),Object(r.b)("h2",null,"axios是如何根据不同宿主环境适配请求方式的？"),Object(r.b)("h3",null,"环境识别"),Object(r.b)("p",null,"axios作为一个http请求库,可用于客户端浏览器,也可以用于nodejs。\n那问题来了,它是如何识别宿主环境的呢？"),Object(r.b)("p",null,"抛开axios本身,我们来想一下,浏览器环境和node环境,到底有什么差异？"),Object(r.b)("p",null,"首先document,window,XMLHttpRequest对象是浏览器环境下才有的。\nprocess,global全局对象是node环境下才有的。\n从这点考虑,我们可以使用document,window,XMLHttpRequest,process,global这些对象进行判断。"),Object(r.b)("p",null,"axios源码中采用了process和XMLHttpRequest。\n通过宿主环境的特有对象识别当前环境,适配出不同环境下的请求方式。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (\n      typeof process !== 'undefined' \n      && Object.prototype.toString.call(process) \n      === '[object process]'\n    ) {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n}\n")),Object(r.b)("p",null,"这部分代码没什么复杂逻辑,根据XMLHttpRequest判定是浏览器环境,实际请求就是xhr。\nnode端相对复杂,使用了Follow Redirects,加强了原生的http和https。"),Object(r.b)("h3",null,"适配时机"),Object(r.b)("p",null,"如果要做适配,放在哪个时机更为合适呢？当然是初始化就安排。\n上边的适配部分导出了一个对象defaults,这个对象被用于创建axios实例。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n  utils.extend(instance, Axios.prototype, context);\n  utils.extend(instance, context);\n  return instance;\n}\n//这里的defaults就是上边导出的包含适配器的defaults\nvar axios = createInstance(defaults);\n\n")),Object(r.b)("h2",null,"axios的拦截器"),Object(r.b)("h3",null,"功能概览"),Object(r.b)("p",null,"拦截器分为请求拦截和响应拦截,可设置多个。但一般只会请求设置一个,响应设置一个。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"请求拦截可用于校验并携带token")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"axios.interceptors.request.use(\n    config => {\n        //请求携带token\n        const token=localStorage.getItem('token');\n        token&&(config.headers.Authorization=token);\n        return config\n    },\n    error=>Promise.reject(error)\n)\n\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"响应拦截可用于数据处理和错误处理")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\naxios.interceptors.response.use(\n  //直接返回响应主体\n    response => response.data,\n    error=>{\n        const {response} =error;   \n        if(response){\n            //有响应内容 根据不同状态码进行不同处理\n            switch(response.status){\n                case 401:{ \n                    //=>权限处理,一般是未登录 ,可跳转至登录页或提示未登录\n                    break;\n                }\n                case 403:{ \n                    //=>服务器拒绝执行,一般是token过期或直接禁止访问\n                    break;\n                }\n                case 404:{ \n                    //=>资源找不到,可跳转至404页面\n                    break;\n                }           \n            }\n\n        }else{\n            //无响应内容 断网或服务器错误\n            if(!window.navigator.onLine){\n                return Promise.reject("网络连接中断,请检查...")\n            }\n            //服务器错误,直接返回错误信息\n            return Promise.reject(error)\n        }\n    }\n)\n\n\n\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"每个设置的拦截器都可以通过eject方法取消拦截")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const req1=axios.interceptors.request.use(config=>{\n  config.headers.count+='req1'\n  return config\n\n})\n//取消请求拦截器\naxios.interceptors.request.eject(req1)\n\nconst res1=axios.interceptors.response.use(config=>{\n  config.headers.count+='res1'\n  return config\n\n})\n//取消响应拦截器\naxios.interceptors.response.eject(res1)\n\n")),Object(r.b)("h3",null,"拦截器到底是个什么东西？"),Object(r.b)("p",null,"看了上边的实现基础使用,也许你会好奇,拦截器本质是什么？\n没什么玄机,其本质就是一个对象,该对象带有成功的处理函数和失败的处理函数。\n看到这是不是想到了promise?是的,就是promise.then接收的两个参数。"),Object(r.b)("p",null,"拦截器源码中维护了一个InterceptorManager,用于拦截器的管理,包括新增和删除。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  //返回值视为id,可用于后续清除无效拦截器\n  return this.handlers.length - 1;\n};\n\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n//剔除无效的拦截器\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\n\n\n")),Object(r.b)("h3",null,"拦截器与请求的执行顺序"),Object(r.b)("p",null,"请求拦截器2=>请求拦截器1=>请求=>响应拦截器1=>响应拦截器2 "),Object(r.b)("p",null,"值得注意的是：请求拦截器先加的后执行,响应拦截器先加的先执行。"),Object(r.b)("p",null,"请求拦截器,实际请求,响应拦截器的执行顺序看起来像一个链条,内部又是怎么串联起来的？\naxios对这部分的实现,让我觉得真是将promise链式调用玩到了极致,看完只觉得震惊。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\nAxios.prototype.request = function request(config) {\n  \n  //...\n\n  // dispatchRequest 实际就是一个xhr\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n//请求前置 \n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n//响应后置 \n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n  return promise;\n};\n\n")),Object(r.b)("p",null,"上述代码通过前后unshift和push将请求拦截和响应拦截放置在真正请求两侧,然后在while循环\n中通过promsie链式不断向后传递,最后将结果返回。"),Object(r.b)("p",null,"实际上的chain是这样的,举个例子:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"var chain = [\n  '请求成功拦截2', '请求失败拦截2',  \n  '请求成功拦截1', '请求失败拦截1',  \n   dispatch,  undefined,\n  '响应成功拦截1', '响应失败拦截1',\n  '响应成功拦截2', '响应失败拦截2',\n]\n\n")),Object(r.b)("p",null,"chain中的相邻两项恰好是对应拦截器的成功回调和失败回调,\n与promise.then(chain.shift(), chain.shift())一一对应。"),Object(r.b)("h2",null,"发起请求"),Object(r.b)("p",null,"接下来就到了关键的时刻,发起请求。其实现并不难,在浏览器端其实就是用了xhr。\n对应相关概念是axios源码中的dispatchRequest和xhr.js。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function dispatchRequest(config) {\n    return new Promise((resolve, reject) => {\n        let { method, url, params, data, timeout } = config;\n        let xhr = new XMLHttpRequest();\n        xhr.responseType = "json";\n        if (params && typeof params === "object") {\n            params = require("qs").stringify(params);\n        } else {\n            params = "";\n        }\n        url += (url.indexOf("?") === -1 ? "?" : "&") + params;\n        xhr.open(method, url, true);\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (\n                 xhr.status >= 200\n                 && xhr.status < 300\n                 ) {\n                   const data=xhr.response ? xhr.response : xhr.responseText\n                    const res = {\n                      config,\n                      data ,\n                      request: xhr,\n                      status: xhr.status,\n                      statusText: xhr.statusText,\n                  };\n                    resolve(res);\n                } else if (\n                  (\n                    xhr.status < 200 && xhr.status !== 0)\n                   || xhr.status > 400\n                   ) {\n                    reject("Error: Request failed with status code " + xhr.status + "");\n                }\n            }\n        };\n\n        xhr.onerror = function () {\n            reject("请求失败");\n        };\n\n        if (timeout) {\n            xhr.ontimeout = function () {\n                reject("Error: timeout of " + timeout + "ms exceeded");\n            };\n        }\n\n        let body = null;\n        if (data) {\n            body = JSON.stringify(data);\n        }\n\n        xhr.send(body);\n    });\n}\n\n\n\n')),Object(r.b)("p",null,"上面代码做了一个简化实现,但其实还可以更精简。是的,上边的一大堆压缩到极致就是三行核心代码。"),Object(r.b)("p",null,"看到这是不是觉得axios的浏览器端请求也不过如此？对的,它本来也不是多复杂,且依赖的就是xhr。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"var xhr=new XMLHttpRequest();\nxhr.open('get',url)\nxhr.send(null)\n\n")),Object(r.b)("p",null,"也许你会问,这就是get请求啊,那其他的请求呢？\naxios的其他http方法实现可以参考下面代码,循环并赋值,其中的request可以视为包装好的xhr。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], \nfunction forEachMethodNoData(method) {\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], \nfunction forEachMethodWithData(method) {\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\n\n")),Object(r.b)("h2",null,"如何取消某个请求呢？"),Object(r.b)("p",null,"爱而不得,果断放手。对于不要的请求,可以直接丢掉。"),Object(r.b)("p",null,"举个例子:tab频繁切换页面,之前的请求可能还没响应完,但确实不再需要。此时,就可取消请求。"),Object(r.b)("h3",null,"基本使用"),Object(r.b)("p",null,"在看具体实现前,先关注一下使用方式。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nimport axios from 'axios'\n\nconst CancelToken = axios.CancelToken;\nconst isCancel = axios.isCancel;//判断是否是用户自主取消\nconst source = CancelToken.source();\naxios({\n cancelToken: source.token,\n})\n\n\naxios(config).catch(err => {\n    if (isCancel(err)) {\n      console.error(err.msg,);\n    } else {\n      console.log(err);\n    }\n  });\n\n  source.cancel(\"cancel\");\n\n\n")),Object(r.b)("p",null,"上边都是模板代码,也没啥玄机。获取CancelToken,执行其source函数。\n其返回值是一个对象,对象上有一个token属性,这个token被作为值传递给axios。"),Object(r.b)("h3",null,"代码实现"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nclass Cancel {\n  public msg: string = "";\n  constructor(msg: string) {\n    this.msg = msg;\n  }\n}\n\nexport function isCancel(err: any) {\n  return err instanceof Cancel;\n}\nexport class CancelToken {\n  public resolve: any;\n\n  source() {\n    return {\n      token: new Promise((resolve) => {\n        this.resolve = resolve;\n      }),\n      cancel: (msg: string) => {\n        this.resolve(new Cancel(msg));\n      },\n    };\n  }\n}\n\n\n\n//dispatchRequest内部调用\n\nif (config.cancelToken) {\n  config.cancelToken.then((msg: string) => {\n      xhr.abort();\n      reject(msg);\n  });\n}\n\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"结合使用,分析一下取消请求的整个过程。")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"source()函数执行,CancelToken类内部属性resolve初始化为promise。"),Object(r.b)("li",{parentName:"ol"},"axios接收的cancelToken其实就是初始化完的promise。"),Object(r.b)("li",{parentName:"ol"},"2中的promise在then函数中调用xhr.abort()完成请求取消,这是最核心的一步。"),Object(r.b)("li",{parentName:"ol"},"then函数中调用reject方法将接收的msg报错信息捕获。"),Object(r.b)("li",{parentName:"ol"},"这个报错信息来源就是外部source.cancel()执行后,resolve(message)的结果。"),Object(r.b)("li",{parentName:"ol"},"axios在xhr外面包了一层Promise,最终,错误信息被catch捕获。")),Object(r.b)("h2",null,"axios面试大概会问什么？"),Object(r.b)("h3",null,"为什么axios既可以当函数调用,也可以当对象使用"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"axios本质是函数,赋值了一些别名方法,比如get、post方法,可被调用"),Object(r.b)("li",{parentName:"ul"},"对象调用是因为获取的是Axios类的实例"),Object(r.b)("li",{parentName:"ul"},"最终调用的还是Axios.prototype.request函数。")),Object(r.b)("h3",null,"简述axios调用流程。"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"创建axios实例"),Object(r.b)("li",{parentName:"ul"},"实际调用的是Axios.prototype.request方法"),Object(r.b)("li",{parentName:"ul"},"最终返回promise链式调用结果"),Object(r.b)("li",{parentName:"ul"},"请求是在dispatchRequest中派发的，浏览器端本质是xhr")),Object(r.b)("h3",null,"聊一聊拦截器？"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"axios.interceptors.request.use添加请求成功和失败拦截器函数"),Object(r.b)("li",{parentName:"ul"},"axios.interceptors.response.use添加响应成功和失败拦截器函数"),Object(r.b)("li",{parentName:"ul"},"在Axios.prototype.request函数组成promise链式调用时, Interceptors.protype.forEach遍历请求和响应拦截器"),Object(r.b)("li",{parentName:"ul"},"通过unshift和push添加到真正发送请求dispatchRequest的两端,从而做到请求前拦截和响应后拦截"),Object(r.b)("li",{parentName:"ul"},"拦截器也支持用Interceptors.protype.eject方法移除。")),Object(r.b)("h3",null,"axios的取消请求功能是怎么实现的？"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"config配置cancelToken"),Object(r.b)("li",{parentName:"ul"},"在promise链式调用的dispatchRequest抛出错误"),Object(r.b)("li",{parentName:"ul"},"在adapter中request.abort()取消请求"),Object(r.b)("li",{parentName:"ul"},"使promise走向rejected"),Object(r.b)("li",{parentName:"ul"},"用户捕获错误信息")),Object(r.b)("h2",null,"源码压缩包"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/lengyuexin/code"}),"https://github.com/lengyuexin/code"))),Object(r.b)("h2",null,"再会"),Object(r.b)("p",null,"情如风雪无常,"),Object(r.b)("p",null,"却是一动既殇。"),Object(r.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(r.b)("p",null,"我是冷月心,下期再见。"))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-axios-index-mdx-58d9e323b837569885c4.js.map