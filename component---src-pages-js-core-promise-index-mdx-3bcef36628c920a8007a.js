(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{LfUm:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return i}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var s=t("7ljp"),r=t("Hv6d"),l=t("JLKy");var c={},o={_frontmatter:c},a=r.a;function i(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,s,r={},l=Object.keys(e);for(s=0;s<l.length;s++)t=l[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(s.b)(a,Object.assign({},o,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("h3",null,"推荐阅读"),Object(s.b)("p",null,Object(s.b)("a",Object.assign({parentName:"p"},{href:"https://juejin.cn/post/6844904116913700877"}),"https://juejin.cn/post/6844904116913700877")),Object(s.b)("h3",null,"Promise(简化版)"),Object(s.b)(l.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"// 先定义三个常量表示状态\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(fn) {\n    this.status = PENDING;    // 初始状态为pending\n    this.value = null;        // 初始化value\n    this.reason = null;       // 初始化reason\n\n    // 构造函数里面添加两个数组存储成功和失败的回调\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    // resolve方法参数是value\n    resolve = (value) => {\n        if (this.status === PENDING) {\n            this.status = FULFILLED;\n            this.value = value;\n            // resolve里面将所有成功的回调拿出来执行\n            this.onFulfilledCallbacks.forEach(callback => {\n                callback(this.value);\n            });\n        }\n    }\n\n    // reject方法参数是reason\n    reject = (reason) => {\n        if (this.status === PENDING) {\n            this.status = REJECTED;\n            this.reason = reason;\n            // resolve里面将所有失败的回调拿出来执行\n            this.onRejectedCallbacks.forEach(callback => {\n                callback(this.reason);\n            });\n        }\n    }\n\n    try {\n        fn(resolve, reject);\n    } catch (error) {\n        reject(error);\n    }\n}\n\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n        onFulfilled(this.value)\n    }\n    if (this.status === REJECTED) {\n        onRejected(this.reason);\n    }\n    // 如果还是PENDING状态，将回调保存下来\n    if (this.status === PENDING) {\n        this.onFulfilledCallbacks.push(onFulfilled);\n        this.onRejectedCallbacks.push(onRejected);\n    }\n    return this\n}\n\n\n\n"))),Object(s.b)("h3",null,"Promise.resolve"),Object(s.b)(l.a,{mdxType:"P"},"如果是Promise的实例,就直接返回。如果不是则用Promise包裹一下后返回"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nPromise.resolve = function (p) {\n    if (p instanceof Promise)  return p;\n    return new Promise(function (resolve) {\n        resolve(p);\n    });\n}\n\n")),Object(s.b)("h3",null,"Promise.reject"),Object(s.b)(l.a,{mdxType:"P"},"返回一个新的Promise实例，该实例的状态为rejected"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nPromise.reject = function (reason) {\n    return new Promise(function (resolve,reject) {\n        reject(reason);\n    });\n}\n\n")),Object(s.b)("h3",null,"Promise.all"),Object(s.b)(l.a,{mdxType:"P"},"接收一个包含promsie的数组",Object(s.b)("br",null),"不是promise的会转为promsie",Object(s.b)("br",null),"必须等待所有的promise成功最后的结果才会resolve",Object(s.b)("br",null),"其最终结果是一个数组,顺序与书写顺序一致",Object(s.b)("br",null),"有一个失败则最终结果失败,返回第一个失败的reject"),Object(s.b)(l.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nfunction all(promises=[]){\n    return new Promise((resolve,reject)=>{\n        let res=[]\n        let count=0;\n        let len=promises.length \n        if(len===0) return resolve(res)\n\n        promises.forEach((p,i)=>{\n            Promise.resolve(p).then((value)=>{\n                count++\n                res[i]=value \n                if(count===len){\n                    resolve(res)\n                }\n            },(reason)=>{\n                reject(reason)\n            })\n        })\n    })\n}\n\n"))),Object(s.b)("h3",null,"Promise.race"),Object(s.b)(l.a,{mdxType:"P"},"接收一个包含promsie的数组",Object(s.b)("br",null),"不是promise的会转为promsie",Object(s.b)("br",null),"不必等待所有的promise成功，最先完成的那个直接返回",Object(s.b)("br",null),"一旦成功或失败不能转为其他状态，会立即结束，resolve和reject也会竞速"),Object(s.b)(l.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\nfunction race(promises = []) {\n    return new Promise((resolve, reject) => {\n        let len = promises.length\n        if (len === 0) return resolve()\n        for (let i = 0; i < len; i++) {\n            const p = promises[i];\n            Promise.resolve(p).then((value) => {\n                return resolve(value)\n            }, (reason) => {\n                return reject(reason)\n            })\n\n        }\n    })\n}\n\n"))),Object(s.b)("h3",null,"catch"),Object(s.b)(l.a,{mdxType:"P"},"Promise中的catch是.then(null, rejection)或.then(undefined, rejection)的别名",Object(s.b)("br",null),"用于指定发生错误时的回调函数"),Object(s.b)(l.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"Promise.prototype.catch = function(onRejected) {\n  this.then(null, onRejected);\n}\n"))))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-js-core-promise-index-mdx-3bcef36628c920a8007a.js.map