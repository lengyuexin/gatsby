(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{NqqT:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return l}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var o=t("7ljp"),a=t("Hv6d"),c=t("JLKy");var s={},r={_frontmatter:s},p=a.a;function l(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,o,a={},c=Object.keys(e);for(o=0;o<c.length;o++)t=c[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(o.b)(p,Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h3",null,"原型链继承"),Object(o.b)(c.a,{mdxType:"P"},"原型中包含的引用值会在所有实例间共享，所以属性通常会在构造函数中定义而不会定义在原型上。 在使用原型实现继承时，原型实际上变成了另一个类型的实例。 这意味着原先的实例属性摇身一变成为了原型属性。"),Object(o.b)(c.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType() {\n    this.colors = ["red", "blue", "green"];\n}\nfunction SubType() { }\n// 继承 SuperType\nSubType.prototype = new SuperType();\nlet instance1 = new SubType();\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nlet instance2 = new SubType();\nconsole.log(instance2.colors); // "red,blue,green,black"\n\n\n'))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"存在的问题")),Object(o.b)(c.a,{style:{background:"lightblue"},mdxType:"P"},"引用共享:在这个例子中,SuperType构造函数定义了一个colors属性，其中包含一个数组(引用值)。 每个SuperType的实例都会有自己的colors属性，包含自己的数组。 但是，当SubType通过原型继承SuperType后,SubType.prototype变成了SuperType的一个实例，因而也获得了自己的colors属性。 这类似于创建了SubType.prototype.colors属性。 最终结果是,SubType的所有实例都会共享这个colors属性。 这一点通过instance1.colors上的修改也能反映到instance2.colors上就可以看出来。"),Object(o.b)(c.a,{style:{background:"#4AC29A"},mdxType:"P"},"无法在子类构造函数中向父类构造函数传参"),Object(o.b)("h3",null,"构造函数继承"),Object(o.b)(c.a,{style:{background:"pink"},mdxType:"P"},"目的：为了解决原型链继承存在的两个问题，出现了构造函数继承",Object(o.b)("br",null),"思路：在子类构造函数中调用父类构造函数,各自绑定上下文，无干扰"),Object(o.b)(c.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType(name) {\n    this.colors = ["red", "blue", "green"];\n    this.name=name\n}\n\n//不写在构造函数中的属性，构造函数继承是获取不到的\nSuperType.prototype.age=18\n//不写在构造函数中的方法，构造函数继承是获取不到的\nSuperType.prototype.say=function(){\n    console.log(\'say super\')\n}\n\nfunction SubType() {\n    // 使用构造函数继承 SuperType\n    SuperType.call(this,\'tom\');\n}\nvar instance1 = new SubType();\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // "red,blue,green"\nconsole.log(instance2.name); // "tom"\nconsole.log(instance2.say); // undefined\nconsole.log(instance2.age); // undefined\n\n'))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"存在问题")),Object(o.b)(c.a,{style:{background:"lightblue"},mdxType:"P"},"必须在构造函数中定义属性和方法，导致函数不能重用",Object(o.b)("br",null),"子类不能访问父类原型上定义的属性和方法"),Object(o.b)("h3",null,"组合继承"),Object(o.b)(c.a,{mdxType:"P"},"原型链继承和构造函数继承是刚好互补的。组合继承就是将原型链和构造函数两者的优点集中了起来。 思路是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性。 这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。"),Object(o.b)(c.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    // 继承属性\n    SuperType.call(this, name); //父类构造函数被执行\n    this.age = age;\n}\n// 继承方法  子类构造器未修正\nSubType.prototype = new SuperType(); //父类构造函数被执行\n\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\nvar instance1 = new SubType("Nicholas", 29);\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\ninstance1.sayName(); // "Nicholas";\ninstance1.sayAge(); // 29\nvar instance2 = new SubType("Greg", 27);\nconsole.log(instance2.colors); // "red,blue,green"\ninstance2.sayName(); // "Greg";\ninstance2.sayAge(); // 27\n'))),Object(o.b)(c.a,{style:{background:"pink"},mdxType:"P"},"组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。 而且组合继承也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力。 看似完美，却并不完美。父类构造函数被执行两次，子类构造器未修正。"),Object(o.b)("h3",null,"寄生组合式继承 (最优继承)"),Object(o.b)(c.a,{style:{background:"lightblue"},mdxType:"P"},"寄生式组合继承通过构造函数继承属性，但使用混合式原型链继承方法。 基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。 说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。"),Object(o.b)(c.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n//取得父类原型的一个副本 \nSubType.prototype=Object.create(SuperType.prototype)\n//无副作用的修正构造器指向\n//原型继承修正会导致一变皆变\nSubType.prototype.constructor=SubType \nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\n'))),Object(o.b)("h3",null,"extends关键字"),Object(o.b)(c.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function A(){\n    //相当于super\n    B.call(this,18)\n    _extends(A, B)//extends\n}\nfunction B(age){\n    this.age=age\n}\n\nfunction _extends(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\n"))))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-js-core-extends-index-mdx-865921a4a36f4ef8784f.js.map