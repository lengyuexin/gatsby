{"version":3,"sources":["webpack:///./src/pages/network/cache/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","style","background","parentName","isMDXComponent"],"mappings":"4RAOO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,4BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,uDAGA,8BACA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,aACXF,QAAQ,KACT,6HAA4G,uBAA5G,4DACmD,uBADnD,mGAGkC,yBAEpC,iCACA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,QACXF,QAAQ,KAFX,wDAGiD,uBAHjD,sDAI+C,uBAJ/C,8DAKuD,uBALvD,0CAMmC,uBANnC,0EAOmE,uBAPnE,yEAQkE,uBARlE,6CASsC,uBATtC,wDAUiD,uBAVjD,0CAaA,8BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,6CACsC,uBADtC,oEAE6D,uBAF7D,4DAGqD,uBAHrD,+DAIwD,uBAJxD,kCAOA,gCACA,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,utBAwBL,+BACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kIAWTN,EAAWO,gBAAiB","file":"component---src-pages-network-cache-index-mdx-e82ddcb4ec5948b841bf.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nimport P from '../../../components/Panel.js';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h3>{`概述`}</h3>\n    <P mdxType=\"P\">\n缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。同样的,缓存也是http层面重要的优化手段。\n    </P>\n    <h3>{`缓存分类`}</h3>\n    <P style={{\n      background: 'lightblue'\n    }} mdxType=\"P\">\n      <p>{`缓存可分为强缓存和协商缓存。强缓存指的是缓存有效期内客户端无需二次向服务端发送请求,直接从缓存中获取,状态码为200。网络请求中的from disk cache ,from memory就表示命中强缓存`}<br />{`\n协商缓存指的是强缓存失效后,客户端需要带上对应的缓存头向服务端发送请求进行协商,服务端对比后决定缓存是否可用。`}<br />{`\n如命中协商缓存,则状态码为304,响应体无内容。更新缓存时间,继续使用,下一轮次将是强缓存(这是一个循环)。\n如强缓存和协商缓存都未命中,客户端需要从服务端获取数据,此时状态码为200。`}<br /></p>\n    </P>\n    <h3>{`相关http头`}</h3>\n    <P style={{\n      background: 'pink'\n    }} mdxType=\"P\">\n对于http头而言,除了方法区分大小写(GET,POST...),其他都是大小写不敏感的,建议首字母大写。<br />\n强缓存:Cache-Control ,Expires,二者同时出现Cache-Control优先生效。<br />\n协商缓存:Last-Modified If-Modified-Since    Etag If-None-Match。<br />\n响应头:Last-Modified,Etag ,二者同时出现Etag优先生效。<br />\n请求头:If-Modified-Since,If-None-Match,前者用于和Last-Modified值比对,后者用于和Etag值比对。<br />\n出现类似功能的头是因为历史原因,Cache-Control基本上可以取代Expires,但是Etag无法完全取代Last-Modified。<br />\nEtag根据文件内容摘要比对,Last-Modified根据修改时间比对,维度不同。<br />\nEtag虽然更精准,但是比起Last-Modified要额外读取文件,进行摘要处理,如果是大文件会很耗时。<br />\n一般情况下,会读取部分文件内容生成摘要。耗时和精准度上来讲,这也是一个取舍。\n    </P>\n    <h3>{`缓存策略`}</h3>\n    <P mdxType=\"P\">\n缓存策略,其实就是通过合理的指定各种缓存相关头的值,从而达到性能优化的一种有效方法。<br />\n对于网站logo这种近乎一两年,甚至十几年都不会变动的,可以直接强缓存Cache-Control设置max-age为年级别的数值。<br />\n涉及频繁读写的场景可以设置强缓存的时间短一些,或者直接Cache-Control:no-cache,进入协商缓存。<br />\n如果是实时读写,缓存可能不太实用,压缩会更有效一些。Cache-Control:no-store 不进行任何数据的缓存。<br />\n抛开实际场景谈缓存意义不大,要根据实际场景按需制定缓存策略。\n    </P>\n    <h3>{`协商缓存实现`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n\n    cache(stat, filePath, req, res) {\n\n        //协商缓存：如果last-modified 和 etag 同时存在,etag优先生效\n        //读取文件内容生成唯一标识\n        const Etag = crypto.createHash('md5').update(fs.readFileSync(filePath)).digest('base64')\n        res.setHeader('Etag', Etag)\n        const ifNoneMatch = req.headers['if-none-match']\n        //返回比对结果\n        if (ifNoneMatch) return ifNoneMatch === Etag\n        //上次修改时间\n        let lastModified = stat.ctime.toGMTString()\n        res.setHeader('Last-Modified', lastModified)\n        const ifModifiedSince = req.headers['if-modified-since']\n        //返回比对结果\n        if (ifModifiedSince) return ifModifiedSince === lastModified\n        //首次没缓存 返回fasle\n        return false\n    }\n\n`}</code></pre>\n    <h3>{`设置强缓存`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nres.setHeader('Cache-Control', \\`max-age=10\\`)\nres.setHeader('Expires', new Date(Date.now() + 10 * 1000).toGMTString())\n\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}