(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{"6KKG":function(e,n,l){"use strict";l.r(n),l.d(n,"_frontmatter",(function(){return u})),l.d(n,"default",(function(){return s}));l("rGqo"),l("yt8O"),l("Btvt"),l("RW0V"),l("91GP"),l("q1tI");var t=l("7ljp"),o=l("Hv6d");var u={},a={_frontmatter:u},r=o.a;function s(e){var n=e.components,l=function(e,n){if(null==e)return{};var l,t,o={},u=Object.keys(e);for(t=0;t<u.length;t++)l=u[t],n.indexOf(l)>=0||(o[l]=e[l]);return o}(e,["components"]);return Object(t.b)(r,Object.assign({},a,l,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,"前言"),Object(t.b)("p",null,"站在面试角度，webpack核心功能实现无非是plugin，loader。\n更深入一点，自然是同步加载和异步加载。\n如果说到加分项,那优化配置，提高打包速度也都算，但这部分不再本系列中。"),Object(t.b)("p",null,"本篇为源码系列核心实现第六篇,对应下图webpack部分。"),Object(t.b)("p",null,Object(t.b)("img",Object.assign({parentName:"p"},{src:"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png",alt:"src"}))),Object(t.b)("h2",null,"同步加载"),Object(t.b)("h3",null,"概述"),Object(t.b)("p",null,"不论是同步加载还是异步加载，webpack打包结果都是一个IIFE。\n该IIFE接收一个类型为对象的modules参数， 该参数是一个以模块路径为key,函数为value的对象,其中函数体是文件内容。\n对于每个require语法，都会被替换为",Object(t.b)("strong",{parentName:"p"},"webpack_require"),"，每个文件路径都会补全为src下相关路径。\nmodule(打包前),chunk(打包过程中),bundle(打包后) 是同一套代码在webpack打包不同时机的不同称呼。"),Object(t.b)("h3",null,"实现"),Object(t.b)("p",null,"直接丢代码了，关键位置已经加了注释，代码不多，应该比较好理解。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"(function (modules) {\n\n    //模块缓存\n    var installedModules = {}\n\n    //自己实现的__webpack_require__ 取代原生的require\n    function __webpack_require__(moduleId) {\n\n        //命中缓存 直接返回\n        if (installedModules[moduleId]) {\n            return installedModules[moduleId].exports\n        }\n        //未命中缓存 添加\n        var module = installedModules[moduleId] = {\n            id: moduleId,//模块id\n            load: false,//默认模块没有被加载,\n            exports: {},//导出的内容\n        }\n\n        //加载对应模块\n        //这里的this指向为module.exports貌似是一种规范\n        modules[moduleId].call(\n          module.exports, module, \n          module.exports, __webpack_require__\n          );\n\n        module.load = true//已经加载\n\n        return module.exports\n\n    }\n\n    //加载入口模块\n    return __webpack_require__('./src/index.js')\n\n})(\n\n    {\n        './src/index.js': (function (module, exports, __webpack_require__) {\n            const title = __webpack_require__('./src/title.js')\n            console.log(title)\n        }),\n        './src/title.js': (function (module, exports,) {\n            module.exports = 'hello'\n        })\n\n\n    })\n\n")),Object(t.b)("p",null,"注意：同步加载用了闭包做缓存，在面试时候这是一个很好的闭包使用场景举例。"),Object(t.b)("h2",null,"异步加载"),Object(t.b)("h3",null,"概述"),Object(t.b)("p",null,"首先要明确一点，异步加载包含同步加载。\n最先被加载的入口文件index.js就是同步加载，异步加载指的是其他模块。\n整个异步加载过程其实有三个重要环节:同步加载，e函数，t函数。"),Object(t.b)("p",null,"同步加载好理解，e函数和t函数是什么东西呢？"),Object(t.b)("p",null,"e函数内部会通过创建script并指定src去加载其他模块，最后会把加载的依赖结果处理成promise返回。\nt函数内部会进行esmodule和commonjs的兼容处理。"),Object(t.b)("h3",null,"打包前vs打包后"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n//打包前\nlet btn = document.createElement('button')\nbtn.innerText = '按我'\ndocument.body.appendChild(btn)\n\nbtn.addEventListener('click', () => {\n    import(/* webpackChunkName:'title' */'./title').then(res => {\n        console.log(res.default)\n    })\n})\n\n\n//打包后\n\n(function (modules) {\n//...    \n}, {\n    \"./src/index.js\":\n\n        (function (module, exports, __webpack_require__) {\n\n            let btn = document.createElement('button');\n            btn.innerText = '按我';\n            document.body.appendChild(btn);\n            btn.addEventListener('click', () => {\n                __webpack_require__.e(/*! import() | title */ \"title\")\n                    .then(__webpack_require__.t.bind(null, \n                    /*! ./title */ \"./src/title.js\", 7))\n                    .then(res => {\n                        console.log(res.default);\n                    });\n            });\n\n        })\n})\n\n\n\n")),Object(t.b)("p",null,"e函数之所以能够.then，是因为已经成了promise。\n根据promise的链式调用原理,e函数return的结果会交给t函数继续处理。\n同理，t函数的处理结果也会再次向后传递。\n而此时的结果必然是兼容处理后的，带有default属性的对象。"),Object(t.b)("h3",null,"异步加载的实现"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n\n  // The module cache\n  var installedModules = {};\n\n  // object to store loaded and loading chunks\n  // undefined = chunk not loaded, null = chunk preloaded/prefetched\n  // Promise = chunk loading, 0 = chunk loaded\n  var installedChunks = {\n    "main": 0\n  };\n\n\n  function __webpack_require__(moduleId) {\n\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module, module.exports,\n      __webpack_require__\n     );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n\n\n  __webpack_require__.e = function (chunkId) {\n\n    var promises = []\n\n    var installedChunkData = installedChunks[chunkId]\n\n     //同样的资源加载后不会加载第二次\n    if (installedChunkData !== 0) {\n      var promise = new Promise(function (resolve, reject) {\n        installedChunkData = installedChunks[chunkId] = [resolve, reject]\n      })\n\n      promises.push(installedChunkData[2] = promise);\n\n      var script = document.createElement(\'script\')\n      script.src = chunkId + \'.bundle.js\'\n      document.head.appendChild(script)\n    }\n\n\n    return Promise.all(promises)\n\n\n  }\n\n\n  var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];\n\n  //核心是push方法\n  jsonpArray.push = webpackJsonpCallback;\n\n\n  // 异步加载的模块结构如下\n\n(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["say"], {\n\n  "./src/say.js":\n    (function (module, exports) {\n      module.exports = \'say import \';\n    })\n\n}]);\n\n//该模块被加载就会执行push方法，也就是执行webpackJsonpCallback\n\n// webpackJsonpCallback 接收一个data参数\n// data形如 [[chunkId1,chunkId2],{}]\n  function webpackJsonpCallback(data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n\n    var moduleId, chunkId, i resolves = [];\n    for ( var = 0; i < chunkIds.length; i++) {\n         chunkId = chunkIds[i];\n         //存储resolves回调数组\n        resolves.push(installedChunks[chunkId][0]);//[resolve,reject,promise]\n      }\n        //将所有加载后的chunkId标识为已加载\n      installedChunks[chunkId] = 0;\n    }\n\n  //将异步加载的模块与原模块合并，后续会在t函数内部执行一次webpack_require加载\n    for (moduleId in moreModules) {\n        modules[moduleId] = moreModules[moduleId];\n    }\n\n   //取出resolves回调数组并逐步执行\n    while (resolves.length) {\n      resolves.shift()();\n    }\n\n\n//t函数会加载异步合并的代码并进行esmodule和commonjs语法的兼容处理\n//经过t函数处理后的结果必然是一个带有default属性的对象\n//promsie中，返回的内容会在下一个then中获取\n\n// 默认进入时mode是7\n // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  __webpack_require__.t = function (value, mode) {\n\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if ((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, \'default\', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != \'string\'){\n      for (var key in value){\n         __webpack_require__.d(ns, key,\n          function (key) { return value[key]; }.bind(null, key)\n          );\n      }\n      \n    } \n    return ns;\n  };\n\n\n  };\n\n\n')),Object(t.b)("p",null,"关键部分已经给出注释，但可能细节上还需要动手多测试，验证。"),Object(t.b)("h2",null,"loader"),Object(t.b)("h3",null,"loader概述"),Object(t.b)("p",null,"webpack本身只能处理js文件，loader就是扩展webpack打包能力用的，\n告诉它非js格式文件该怎么处理。比如css相关的style-loader,css-loader。"),Object(t.b)("p",null,"loader其实和node中的pipe很像，如同流水线，一个loader之后可以接另一个loader。\n但最终，必须是一个js形式收尾。"),Object(t.b)("h3",null,"实现一个简易loader"),Object(t.b)("p",null,"loader的本质是一个函数，该函数通过source参数接收输入，通过返回值输出。\n下面以一个markdown-loader为例，举例说明一个loader是如何实现的。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const marked = require('marked')\nmodule.exports = source => {\n  const html = marked(source)\n  return  `module.exports = ${JSON.stringify(html)}`\n}\n")),Object(t.b)("p",null,"这就完事了？是的，就是如此简单。\n测试的话，这个loader可以在webpack的配置文件中以本地路径形式加载。"),Object(t.b)("h2",null,"plugin"),Object(t.b)("h3",null,"plugin概述"),Object(t.b)("p",null,"Webpack 的插件本质就是各种钩子，这就像组件生命周期一样，不同阶段存在不同钩子函数。\nwebpack赋予了这些钩子函数特定的能力，直接拿过来用就行了。"),Object(t.b)("h3",null,"实现一个简易plugin"),Object(t.b)("p",null,"plugin可以写成一个类的形式，然后身上有个apply方法，这个是webpack约定好的。\n下面写一个简单的小插件，用于打印构建过程涉及的文件名。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"class GetFileListPlugin {\n    apply(compiler) {\n        compiler.hooks.emit.tap('GetFileListPlugin ', compilation => {\n            // compilation => 可以理解为此次打包的上下文\n            for (const name in compilation.assets) {\n                console.log(name)\n                const contents = compilation.assets[name].source()\n                compilation.assets[name] = {\n                    //用于返回新内容 \n                    source: () => contents,\n                    //返回内容大小\n                    size: () => noComments.length\n                }\n            }\n        })\n\n    }\n}\n\nmodule.exports = GetFileListPlugin\n\n")),Object(t.b)("h2",null,"源码压缩包"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/lengyuexin/code"}),"https://github.com/lengyuexin/code"))),Object(t.b)("h2",null,"再会"),Object(t.b)("p",null,"情如风雪无常,"),Object(t.b)("p",null,"却是一动既殇。"),Object(t.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(t.b)("p",null,"我是冷月心,下期再见。"))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-webpack-index-mdx-6b6c48891dd8120698a4.js.map