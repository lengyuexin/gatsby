(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{pAmV:function(e,t,b){"use strict";b.r(t),b.d(t,"_frontmatter",(function(){return o})),b.d(t,"default",(function(){return j}));var n=b("shca"),c=(b("xwgP"),b("N0F1")),l=b("Hv6d"),r=b("JLKy"),o={},u={_frontmatter:o},O=l.default;function j(e){var t=e.components,b=Object(n.a)(e,["components"]);return Object(c.b)(O,Object.assign({},u,b,{components:t,mdxType:"MDXLayout"}),Object(c.b)("h2",null,"XSS"),Object(c.b)("h3",null,"描述"),Object(c.b)(r.a,{mdxType:"P"},"XSS全称是CrossnSite Scripting(跨站脚本)，为了和CSS区分，故叫它XSS。 XSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。 如:窃取Cookie,监听用户行为(如输入账号密码后直接发送到黑客服务器),修改 DOM 伪造登录表单,生成浮窗广告。"),Object(c.b)("h3",null,"类型"),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"XSS攻击的实现主要有三种方式:存储型、反射型和文档型")),Object(c.b)(r.a,{mdxType:"P"},Object(c.b)("p",null,"存储型就是将恶意脚本存储到数据库，服务端读取后返回，客户端执行。常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库。\n在页面渲染过程中直接执行, 相当于执行一段未知逻辑的JS代码，安全性得不到保障。",Object(c.b)("br",null),"\n反射型XSS指的是恶意脚本作为网络请求的参数，经过服务器，然后再反射到HTML文档中",Object(c.b)("br",null),"\n文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档！")),Object(c.b)("h3",null,"防范"),Object(c.b)(r.a,{mdxType:"P"},"对用户的输入进行转义  ",Object(c.b)("br",null),"CSP内容安全策略限制其他域下的资源加载,禁止向其它域提交数据,提供上报机制",Object(c.b)("br",null),"利用HttpOnly,使得js无法操控cookie",Object(c.b)("br",null)),Object(c.b)("h2",null,"CSRF攻击"),Object(c.b)("h3",null,"描述"),Object(c.b)(r.a,{style:{background:"lightblue"},mdxType:"P"},"CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。 自动发GET(图片链接)请求获取个人信息,自动post表单提交进行转账汇款以及其他的恶意操作"),Object(c.b)("h3",null,"防范"),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"1. 利用Cookie的SameSite属性，可以设置为三个值:Strict、Lax和None")),Object(c.b)(r.a,{style:{background:"#4AC29A"},mdxType:"P"},"在Strict模式下，浏览器完全禁止第三方请求携带Cookie",Object(c.b)("br",null),"在None模式下，也就是默认模式，请求会自动携带上 Cookie",Object(c.b)("br",null),"在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a标签发送get请求的情况下可以携带Cookie"),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"2.  验证来源站点")),Object(c.b)(r.a,{style:{background:"#4AC29A"},mdxType:"P"},"这就需要要用到请求头中的两个字段: Origin和Referer",Object(c.b)("br",null),"这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。",Object(c.b)("br",null)),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"3. CSRF Token")),Object(c.b)(r.a,{style:{background:"#4AC29A"},mdxType:"P"},"浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。",Object(c.b)("br",null),"浏览器发送请求，会带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应",Object(c.b)("br",null),"这个字符串就是CSRF Token，通常第三方站点无法拿到这个 token, 会被服务器给拒绝。"))}j.isMDXComponent=!0},shca:function(e,t,b){"use strict";function n(e,t){if(null==e)return{};var b,n,c={},l=Object.keys(e);for(n=0;n<l.length;n++)b=l[n],t.indexOf(b)>=0||(c[b]=e[b]);return c}b.d(t,"a",(function(){return n}))}}]);
//# sourceMappingURL=component---src-pages-xss-csrf-index-mdx-afaaf69b2e89e7c0a54a.js.map