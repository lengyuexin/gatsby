{"version":3,"sources":["webpack:///./src/pages/remove-useless-code/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,4BACA,gDACA,sEACA,6CACA,kCACA,oDACA,oCACA,wDACA,sBACE,kBAAIC,WAAW,MAAf,mBACA,kBAAIA,WAAW,MAAf,wBACA,kBAAIA,WAAW,MAAf,aACA,kBAAIA,WAAW,MAAf,cAEF,8BACA,4CACA,4CACA,uCACA,qCACA,4DACA,sBACE,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,sCAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,gCAGJ,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,+aA6BL,uFACA,iCACA,yEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4GAQL,yDACA,6HACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8HAUL,oCACA,iEACA,wEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qFAQL,iCACA,mDAAkC,+BAAGA,WAAW,KAAQ,CACpD,KAAQ,+CADsB,OAAlC,aAGA,4BACA,gCACA,gCACA,yCACA,qCAKJJ,EAAWK,gBAAiB","file":"component---src-pages-remove-useless-code-index-mdx-4128187bc25703f9078f.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`前言`}</h2>\n    <p>{` 随着业务的不断迭代，项目代码会变得越来越多。`}</p>\n    <p>{` 如果前期不注意开发规范和代码层次结构规划，到后期项目中就会出现大量的冗余代码，维护困难。`}</p>\n    <p>{` 到最后，多是以重构，新建项目重写收尾。`}</p>\n    <p>{`原本，可以更好的。`}</p>\n    <p>{`本周双休，今天我们就来聊一下如何减少项目中的冗余代码。`}</p>\n    <h2>{`为什么会出现冗余代码`}</h2>\n    <p>{`结合我的经验来看，出现冗余代码的情况包括但不限于以下几个方面：`}</p>\n    <ul>\n      <li parentName=\"ul\">{`对于公共请求/业务逻辑未做提取`}</li>\n      <li parentName=\"ul\">{`能收敛为聚合函数的函数直接提供给外部调用`}</li>\n      <li parentName=\"ul\">{`能合并的函数未合并`}</li>\n      <li parentName=\"ul\">{`相似结构的复制粘贴`}</li>\n    </ul>\n    <h2>{`如何解决`}</h2>\n    <p>{`核心思想是能合并的合并，能提取的提取。`}</p>\n    <p>{`其实都是建议，这种东西，咬牙也能坚持。`}</p>\n    <p>{`能过就过，不能过还能离咋的？`}</p>\n    <h3>{`提取公共请求/业务逻辑`}</h3>\n    <p>{`比如对某项数据进行订阅和取消订阅，二者只是动作上的区别，参数是一致的。`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`不要在每个模块下都写一份订阅和取消订阅的逻辑，提取到全局公共逻辑中`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`不要写两个处理函数，用动作区分即可（以mobx为例）`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// subscribes 为用户订阅数据id集合\n\n// bad case\nif(subscribes.includes(row.id)){\n    store.cancel()\n}else{\n    store.add()\n}\n\n\n// good case\n\nstore.subscribe(row.id,subscribes.includes(row.id))\n\nasync function subscribe(id,flag){\n    let url=''\n    if(flag){\n        // 取消订阅\n        url='/api/subscribe/cancel'\n    }else{\n        //新增订阅\n        url='/api/subscribe/add'\n    }\n    await axios.post(url,{id})\n}\n\n`}</code></pre>\n    <p>{`此外，还有一个更典型的场景。登录平台获取用户信息后，为方便其他模块使用，这个信息应该放在全局，而不是每次使用再去发一个请求。`}</p>\n    <h3>{`聚合函数的收敛`}</h3>\n    <p>{`给定这样一个场景，新建项目并指定负责人后，会同步资源(该项目)到权限系统，并为资源对应的人赋权。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// bad case \n// 创建或者更新资源信息\nexport function addOrUpdate(){}\n//赋权\nexport function addPermission(){}\n`}</code></pre>\n    <p>{`上述这种写法存在一个弊端，直接提供给外部的话，两个方法都要调用。`}</p>\n    <p>{`事实上，这两个是一体的行为，创建或者更新资源后，紧接着就是赋权。addPermission是addOrUpdate的子函数，直接内部调用就好。这样外部只需要调用聚合后的函数addOrUpdate即可。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// good case \n// 创建或者更新资源信息\nexport function addOrUpdate(){\n    addPermission();\n}\n//赋权\nfunction addPermission(){}\n`}</code></pre>\n    <h3>{`能合并的函数进行合并`}</h3>\n    <p>{`这个比较好理解，就像上边提到的订阅和取消订阅，只是动作差异，完全可以合并为一个。`}</p>\n    <p>{`此外，类似的还有插入数据和更新数据，这里动作判断标准是是否有id,有的就是更新，没有就是插入。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`if(params.id){\n    service.update(params)\n}else{\n    service.add(params)\n}\n`}</code></pre>\n    <h3>{`善用配置表思维`}</h3>\n    <p>{`之所以选择复制粘贴，是因为相似结构很多，对于这种情况，`}<a parentName=\"p\" {...{\n        \"href\": \"https://juejin.cn/post/6960562154839900190\"\n      }}>{`配置表`}</a>{`+循环则是更优解。`}</p>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动即殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}