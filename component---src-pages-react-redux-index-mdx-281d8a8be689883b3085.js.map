{"version":3,"sources":["webpack:///./src/pages/react-redux/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"gRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,4BACA,4GAEA,+EACA,0DACA,qBAAG,iCAAKC,WAAW,KAAQ,CACvB,IAAO,sFACP,IAAO,UAEX,yBACE,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,gCAAIA,WAAW,MAAS,CACtB,MAAS,QAEX,gCAAIA,WAAW,MAAS,CACtB,MAAS,UAIf,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,QAGA,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,SAIF,kBAAIA,WAAW,SACb,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,YAGA,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,UAIF,kBAAIA,WAAW,SACb,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,WAGA,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,YAIF,kBAAIA,WAAW,SACb,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,WAGA,gCAAIA,WAAW,MAAS,CACtB,MAAS,OADX,2BAMN,0CACA,gEACA,8BACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,mJAYL,4BACA,qBAAG,sBAAQA,WAAW,KAAnB,eACH,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4EAML,qBAAG,sBAAQA,WAAW,KAAnB,gBACH,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qRAiBL,gEAEA,iCACA,wCACA,2CACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yHASL,qEAEA,4DACA,wMAGA,4EACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4MAkBL,gIAEA,qBAAG,sBAAQA,WAAW,KAAnB,UACH,oDACA,oMAIA,qBAAG,sBAAQA,WAAW,KAAnB,4BACH,gOAGA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kQAyBL,8CACA,oCACA,wEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,2zCAiDL,sBACE,kBAAIA,WAAW,MAAf,yCACA,kBAAIA,WAAW,MAAf,6DACA,kBAAIA,WAAW,MAAf,sDACA,kBAAIA,WAAW,MAAf,yEACA,kBAAIA,WAAW,MAAf,0EACA,kBAAIA,WAAW,MAAf,kBAEF,+BACA,sBACE,kBAAIA,WAAW,MAAK,+BAAGA,WAAW,MAAS,CACvC,KAAQ,uCADQ,wCAItB,4BACA,gCACA,gCACA,yCACA,qCAKJJ,EAAWK,gBAAiB","file":"component---src-pages-react-redux-index-mdx-281d8a8be689883b3085.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`前言`}</h2>\n    <p>{`react-redux作为react和redux的粘合剂,可完成状态的订阅与更新。\n这部分涉及的核心功能点有三个:provider,context,connect。`}</p>\n    <p>{`面试高频:connect,mapStateToProps,mapDispatchToProps的应用和原理。`}</p>\n    <p>{`本篇为源码系列核心实现第四篇,对应下图react-redux部分。`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png\",\n        \"alt\": \"src\"\n      }}></img></p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}></th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}></th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`name`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`desc`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`provider`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`数据提供方`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`context`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`状态上下文对象`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`connect`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`高阶组件,被包装后的组件可连接store`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <h2>{`Provider与Context`}</h2>\n    <p>{`Provider用于向所有组件传递数据仓库store,配合Context使用。`}</p>\n    <h3>{`基本使用`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`//store来源于redux中createStore方法的返回值。\n function App() {\n  return (\n    <Provider store={store}>\n      <Child />\n    </Provider>\n  );\n}\n\n`}</code></pre>\n    <h3>{`实现`}</h3>\n    <p><strong parentName=\"p\">{`context的实现`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const context = React.createContext(null);\nexport default context;\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`provider的实现`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n//ReactReduxContext就是上边的context\n class Provider extends Component{\n  render() {\n    return (\n      <ReactReduxContext.Provider\n        value={{store: this.props.store}}\n      >\n        {this.props.children}\n      </ReactReduxContext.Provider>\n    );\n  }\n}\n\n`}</code></pre>\n    <p>{`这就完事了？是的,大道至简。\n关键也不在这里,下面来看重头戏connect。`}</p>\n    <h2>{`connect`}</h2>\n    <h3>{`connect是怎么使用的？`}</h3>\n    <p>{`了解其背后实现前,先看一下大概用法。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { connect } from 'react-redux'\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App)\n\n`}</code></pre>\n    <p>{`就这？对,就这一下子就完事了。\nconnect是高阶函数,最后会返回一个包装后的组件。`}</p>\n    <h3>{`mapStateToProps和mapDispatchToProps`}</h3>\n    <p>{`connect方法可接受两个参数:mapStateToProps和mapDispatchToProps。\n其中mapStateToProps用于将从store中获取的state映射到被包裹组件的props上,主要用于数据渲染。\nmapDispatchToProps是将交互逻辑映射成action后传递给被包装后的组件,主要用于事件交互(如点击)。`}</p>\n    <p>{`mapStateToProps是一个函数,最后会返回一个对象,对象属性为store中状态树的同名属性。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`//store中数据\nstate:{\n    name:'冷月心'\n}\nconst mapStateToProps = (state) => {\n  return {\n    name:state.name\n  }\n}\n\n//被connect包裹后组件props中可以拿到name属性\nfunction App(props){\n props.name//冷月心\n}\n\n`}</code></pre>\n    <p>{`mapStateToProps会订阅 Store,state更新会触发视图的重新渲染,这在react中表现为setState。\n这部分就涉及到了subscribe和setState,暂且略过,下文会提到。`}</p>\n    <p><strong parentName=\"p\">{`第二个参数`}</strong></p>\n    <p>{`我之前面试,忘了哪个面家面试官问的了,但确实没回答上。`}</p>\n    <p>{`他问我mapStateToProps和mapDispatchToProps的第二个参数是什么？\n说实话我脑瓜子嗡嗡的,当时一脸诧异,这还有第二个参数？\n后来了解到确实有,就是组件自身的props,也可以叫ownProps。\n且ownProps发生改变,mapStateToProps和mapDispatchToProps就会重新被调用。`}</p>\n    <p><strong parentName=\"p\">{`不同类型的mapDispatchToProps`}</strong></p>\n    <p>{`与mapStateToProps不同,mapDispatchToProps可以是一个对象,也可以是一个函数。\nconnect内部,对象类型的mapDispatchToProps会使用bindActionCreators完成ActionCreators与dispatch的绑定。\n函数类型的mapDispatchToProps会接收一个dispatch参数,返回dispatch后的action。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`//函数形式\nconst mapDispatchToProps = (\n  dispatch\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'ADD',\n      });\n    }\n  };\n}\n\n//对象形式\n\nconst mapDispatchToProps = {\n  onClick: () => ({\n    type: 'ADD',\n  })\n}\n\n\n`}</code></pre>\n    <p>{`具体使用哪种形式还是看个人习惯，喜欢就好。`}</p>\n    <h3>{`connect的实现`}</h3>\n    <p>{` connect一共做了四件事:订阅,状态映射,dispatch映射,返回扩展后的被包裹组件。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nimport React from \"react\";\nimport bindActionCreators from \"../redux/bindActionCreators\";\nimport ReactReduxContext from \"./Context\";\nexport default function (mapStateToProps, mapDispatchToProps) {\n  return function (OldComponent) {\n    return class newComponent extends React.Component {\n      unsubscribe;\n      static contextType = ReactReduxContext;\n      constructor(props, context) {\n        super(props);\n        this.state = mapStateToProps(context.store.getState());\n      }\n\n      componentDidMount() {\n        this.unsubscribe = this.context.store.subscribe(() => {\n          // mapStateToProps接收一个state参数,返回一个state对象\n          this.setState(mapStateToProps(this.context.store.getState()));\n        });\n      }\n\n      componentWillUnmount() {\n        this.unsubscribe();\n      }\n\n      render() {\n        let actions;\n        if (typeof mapDispatchToProps === \"function\") {\n          actions = mapDispatchToProps(this.context.store.dispatch);\n        } else if (\n          mapDispatchToProps &&\n          typeof mapDispatchToProps === \"object\"\n        ) {\n          actions = bindActionCreators(\n            mapDispatchToProps,\n            this.context.store.dispatch\n          );\n        }\n\n        return <OldComponent {...this.state} {...actions} />;\n      }\n    };\n  };\n}\n\n\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`connect在挂载阶段订阅更新函数setState,在卸载阶段取消订阅。`}</li>\n      <li parentName=\"ul\">{`connect从context的store中调用getState,返回值作为参数给mapStateToProps。`}</li>\n      <li parentName=\"ul\">{`mapStateToProps函数执行的返回值用于初始化this.state,之后传递给被包裹组件。`}</li>\n      <li parentName=\"ul\">{`对于dispatch映射分为两种情况,如果mapDispatchToProps是一个对象,就需要用bingActionCreators绑定`}</li>\n      <li parentName=\"ul\">{`如果mapDispatchToProps是一个函数,就给这个函数传递dispatch参数并调用,最后返回的actions传递给被包裹的组件。`}</li>\n      <li parentName=\"ul\">{`最终,将映射完的组件返回。`}</li>\n    </ul>\n    <h2>{`源码压缩包`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/lengyuexin/code\"\n        }}>{`https://github.com/lengyuexin/code`}</a></li>\n    </ul>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动既殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}