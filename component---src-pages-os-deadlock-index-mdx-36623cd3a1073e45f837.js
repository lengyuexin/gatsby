(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{reK6:function(t,n,e){"use strict";e.r(n),e.d(n,"_frontmatter",(function(){return o})),e.d(n,"default",(function(){return s}));var b=e("shca"),c=(e("xwgP"),e("N0F1")),r=e("Hv6d"),u=e("JLKy"),o={},l={_frontmatter:o},a=r.default;function s(t){var n=t.components,e=Object(b.a)(t,["components"]);return Object(c.b)(a,Object.assign({},l,e,{components:n,mdxType:"MDXLayout"}),Object(c.b)("h3",null,"解释"),Object(c.b)(u.a,{mdxType:"P"},"死锁是指两个或两个以上的进程在执行过程中,由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。 若无外力作用,它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。"),Object(c.b)("h3",null,"产生条件"),Object(c.b)(u.a,{style:{background:"#4AC29A"},mdxType:"P"},"互斥：在一段时间内某资源只由一个进程占用,必须释放后其他的进程才能使用。",Object(c.b)("br",null),"请求和保持：指进程已经保持至少一个资源,但又提出了新的资源请求, 而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放。",Object(c.b)("br",null),"不剥夺：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放。",Object(c.b)("br",null),"环路等待：指在发生死锁时,必然存在一个进程——资源的环形链p0=>p1=>p2=>p0",Object(c.b)("br",null)),Object(c.b)("h3",null,"预防"),Object(c.b)(u.a,{style:{background:"lightblue"},mdxType:"P"},"破坏产生死锁原因中的任意某个条件,如:有序资源分配法,银行家算法"))}s.isMDXComponent=!0},shca:function(t,n,e){"use strict";function b(t,n){if(null==t)return{};var e,b,c={},r=Object.keys(t);for(b=0;b<r.length;b++)e=r[b],n.indexOf(e)>=0||(c[e]=t[e]);return c}e.d(n,"a",(function(){return b}))}}]);
//# sourceMappingURL=component---src-pages-os-deadlock-index-mdx-36623cd3a1073e45f837.js.map