{"version":3,"sources":["webpack:///./src/pages/js-core/extends/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","style","background","parentName","isMDXComponent"],"mappings":"4RAOO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,+BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,qGAKA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXF,QAAQ,KACT,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,sXAiBP,qBAAG,sBAAQA,WAAW,KAAnB,UACH,YAAC,IAAD,CAAGF,MAAO,CACRC,WAAY,aACXF,QAAQ,KAFX,6SAUA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXF,QAAQ,KAFX,uBAKA,gCACA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,QACXF,QAAQ,KAFX,gCAGyB,uBAHzB,mCAMA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXF,QAAQ,KACT,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,yqBA6BP,qBAAG,sBAAQA,WAAW,KAAnB,SACH,YAAC,IAAD,CAAGF,MAAO,CACRC,WAAY,aACXF,QAAQ,KAFX,2BAGoB,uBAHpB,uBAMA,8BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,yHAKA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXF,QAAQ,KACT,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,4xBA+BP,YAAC,IAAD,CAAGF,MAAO,CACRC,WAAY,QACXF,QAAQ,KAFX,0IAOA,wCACA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,aACXF,QAAQ,KAFX,iHAOA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXF,QAAQ,KACT,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,4eAyBP,oCACA,YAAC,IAAD,CAAGF,MAAO,CACRC,WAAY,WACXF,QAAQ,KACT,uBAAK,kCAAMG,WAAW,OAAU,CAC5B,UAAa,gBADZ,2WA2BXN,EAAWO,gBAAiB","file":"component---src-pages-js-core-extends-index-mdx-c7e547fefcd30c42cf86.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nimport P from '../../../components/Panel.js';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h3>{`原型链继承`}</h3>\n    <P mdxType=\"P\">\n原型中包含的引用值会在所有实例间共享，所以属性通常会在构造函数中定义而不会定义在原型上。\n在使用原型实现继承时，原型实际上变成了另一个类型的实例。\n这意味着原先的实例属性摇身一变成为了原型属性。\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`function SuperType() {\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType() { }\n// 继承 SuperType\nSubType.prototype = new SuperType();\nlet instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); // \"red,blue,green,black\"\nlet instance2 = new SubType();\nconsole.log(instance2.colors); // \"red,blue,green,black\"\n\n\n`}</code></pre>\n    </P>\n    <p><strong parentName=\"p\">{`存在的问题`}</strong></p>\n    <P style={{\n      background: 'lightblue'\n    }} mdxType=\"P\">\n引用共享:在这个例子中,SuperType构造函数定义了一个colors属性，其中包含一个数组(引用值)。\n每个SuperType的实例都会有自己的colors属性，包含自己的数组。\n但是，当SubType通过原型继承SuperType后,SubType.prototype变成了SuperType的一个实例，因而也获得了自己的colors属性。\n这类似于创建了SubType.prototype.colors属性。\n最终结果是,SubType的所有实例都会共享这个colors属性。\n这一点通过instance1.colors上的修改也能反映到instance2.colors上就可以看出来。\n    </P>\n    <P style={{\n      background: '#4AC29A'\n    }} mdxType=\"P\">\n 无法在子类构造函数中向父类构造函数传参\n    </P>\n    <h3>{`构造函数继承`}</h3>\n    <P style={{\n      background: 'pink'\n    }} mdxType=\"P\">\n目的：为了解决原型链继承存在的两个问题，出现了构造函数继承<br />\n思路：在子类构造函数中调用父类构造函数,各自绑定上下文，无干扰\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`function SuperType(name) {\n    this.colors = [\"red\", \"blue\", \"green\"];\n    this.name=name\n}\n\n//不写在构造函数中的属性，构造函数继承是获取不到的\nSuperType.prototype.age=18\n//不写在构造函数中的方法，构造函数继承是获取不到的\nSuperType.prototype.say=function(){\n    console.log('say super')\n}\n\nfunction SubType() {\n    // 使用构造函数继承 SuperType\n    SuperType.call(this,'tom');\n}\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); // \"red,blue,green,black\"\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // \"red,blue,green\"\nconsole.log(instance2.name); // \"tom\"\nconsole.log(instance2.say); // undefined\nconsole.log(instance2.age); // undefined\n\n`}</code></pre>\n    </P>\n    <p><strong parentName=\"p\">{`存在问题`}</strong></p>\n    <P style={{\n      background: 'lightblue'\n    }} mdxType=\"P\">\n必须在构造函数中定义属性和方法，导致函数不能重用<br />\n子类不能访问父类原型上定义的属性和方法\n    </P>\n    <h3>{`组合继承`}</h3>\n    <P mdxType=\"P\">\n原型链继承和构造函数继承是刚好互补的。组合继承就是将原型链和构造函数两者的优点集中了起来。\n思路是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性。\n这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`function SuperType(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    // 继承属性\n    SuperType.call(this, name); //父类构造函数被执行\n    this.age = age;\n}\n// 继承方法  子类构造器未修正\nSubType.prototype = new SuperType(); //父类构造函数被执行\n\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); // \"red,blue,green,black\"\ninstance1.sayName(); // \"Nicholas\";\ninstance1.sayAge(); // 29\nvar instance2 = new SubType(\"Greg\", 27);\nconsole.log(instance2.colors); // \"red,blue,green\"\ninstance2.sayName(); // \"Greg\";\ninstance2.sayAge(); // 27\n`}</code></pre>\n    </P>\n    <P style={{\n      background: 'pink'\n    }} mdxType=\"P\">\n组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。\n而且组合继承也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力。\n看似完美，却并不完美。父类构造函数被执行两次，子类构造器未修正。\n    </P>\n    <h3>{`寄生组合式继承 (最优继承)`}</h3>\n    <P style={{\n      background: 'lightblue'\n    }} mdxType=\"P\">\n寄生式组合继承通过构造函数继承属性，但使用混合式原型链继承方法。\n基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。\n说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n//取得父类原型的一个副本 \nSubType.prototype=Object.create(SuperType.prototype)\n//无副作用的修正构造器指向\n//原型继承修正会导致一变皆变\nSubType.prototype.constructor=SubType \nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\n`}</code></pre>\n    </P>\n    <h3>{`extends关键字`}</h3>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`function A(){\n    //相当于super\n    B.call(this,18)\n    _extends(A, B)//extends\n}\nfunction B(age){\n    this.age=age\n}\n\nfunction _extends(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\n`}</code></pre>\n    </P>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}