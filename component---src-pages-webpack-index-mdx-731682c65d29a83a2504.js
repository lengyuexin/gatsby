(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{"6KKG":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return o})),t.d(n,"default",(function(){return u}));var l=t("shca"),a=(t("xwgP"),t("N0F1")),r=t("Hv6d"),o={},s={_frontmatter:o},c=r.a;function u(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(a.b)(c,Object.assign({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"前言"),Object(a.b)("p",null,"站在面试角度，webpack核心功能实现无非是plugin，loader。\n更深入一点，自然是同步加载和异步加载。\n如果说到加分项,那优化配置，提高打包速度也都算，但这部分不再本系列中。"),Object(a.b)("p",null,"本篇为源码系列核心实现第六篇,对应下图webpack部分。"),Object(a.b)("p",null,Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png",alt:"src"}))),Object(a.b)("h2",null,"同步加载"),Object(a.b)("h3",null,"概述"),Object(a.b)("p",null,"不论是同步加载还是异步加载，webpack打包结果都是一个IIFE。\n该IIFE接收一个类型为对象的modules参数， 该参数是一个以模块路径为key,函数为value的对象,其中函数体是文件内容。\n对于每个require语法，都会被替换为",Object(a.b)("strong",{parentName:"p"},"webpack_require"),"，每个文件路径都会补全为src下相关路径。\nmodule(打包前),chunk(打包过程中),bundle(打包后) 是同一套代码在webpack打包不同时机的不同称呼。"),Object(a.b)("h3",null,"实现"),Object(a.b)("p",null,"直接丢代码了，关键位置已经加了注释，代码不多，应该比较好理解。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"(function (modules) {\n\n    //模块缓存\n    var installedModules = {}\n\n    //自己实现的__webpack_require__ 取代原生的require\n    function __webpack_require__(moduleId) {\n\n        //命中缓存 直接返回\n        if (installedModules[moduleId]) {\n            return installedModules[moduleId].exports\n        }\n        //未命中缓存 添加\n        var module = installedModules[moduleId] = {\n            id: moduleId,//模块id\n            load: false,//默认模块没有被加载,\n            exports: {},//导出的内容\n        }\n\n        //加载对应模块\n        //这里的this指向为module.exports貌似是一种规范\n        modules[moduleId].call(\n          module.exports, module, \n          module.exports, __webpack_require__\n          );\n\n        module.load = true//已经加载\n\n        return module.exports\n\n    }\n\n    //加载入口模块\n    return __webpack_require__('./src/index.js')\n\n})(\n\n    {\n        './src/index.js': (function (module, exports, __webpack_require__) {\n            const title = __webpack_require__('./src/title.js')\n            console.log(title)\n        }),\n        './src/title.js': (function (module, exports,) {\n            module.exports = 'hello'\n        })\n\n\n    })\n\n")),Object(a.b)("p",null,"注意：同步加载用了闭包做缓存，在面试时候这是一个很好的闭包使用场景举例。"),Object(a.b)("h2",null,"异步加载"),Object(a.b)("h3",null,"概述"),Object(a.b)("p",null,"首先要明确一点，异步加载包含同步加载。\n最先被加载的入口文件index.js就是同步加载，异步加载指的是其他模块。\n整个异步加载过程其实有三个重要环节:同步加载，e函数，t函数。"),Object(a.b)("p",null,"同步加载好理解，e函数和t函数是什么东西呢？"),Object(a.b)("p",null,"e函数内部会通过创建script并指定src去加载其他模块，最后会把加载的依赖结果处理成promise返回。\nt函数内部会进行esmodule和commonjs的兼容处理。"),Object(a.b)("h3",null,"打包前vs打包后"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n//打包前\nlet btn = document.createElement('button')\nbtn.innerText = '按我'\ndocument.body.appendChild(btn)\n\nbtn.addEventListener('click', () => {\n    import(/* webpackChunkName:'title' */'./title').then(res => {\n        console.log(res.default)\n    })\n})\n\n\n//打包后\n\n(function (modules) {\n//...    \n}, {\n    \"./src/index.js\":\n\n        (function (module, exports, __webpack_require__) {\n\n            let btn = document.createElement('button');\n            btn.innerText = '按我';\n            document.body.appendChild(btn);\n            btn.addEventListener('click', () => {\n                __webpack_require__.e(/*! import() | title */ \"title\")\n                    .then(__webpack_require__.t.bind(null, \n                    /*! ./title */ \"./src/title.js\", 7))\n                    .then(res => {\n                        console.log(res.default);\n                    });\n            });\n\n        })\n})\n\n\n\n")),Object(a.b)("p",null,"e函数之所以能够.then，是因为已经成了promise。\n根据promise的链式调用原理,e函数return的结果会交给t函数继续处理。\n同理，t函数的处理结果也会再次向后传递。\n而此时的结果必然是兼容处理后的，带有default属性的对象。"),Object(a.b)("h3",null,"异步加载的实现"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n\n  // The module cache\n  var installedModules = {};\n\n  // object to store loaded and loading chunks\n  // undefined = chunk not loaded, null = chunk preloaded/prefetched\n  // Promise = chunk loading, 0 = chunk loaded\n  var installedChunks = {\n    "main": 0\n  };\n\n\n  function __webpack_require__(moduleId) {\n\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module, module.exports,\n      __webpack_require__\n     );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n\n\n  __webpack_require__.e = function (chunkId) {\n\n    var promises = []\n\n    var installedChunkData = installedChunks[chunkId]\n\n     //同样的资源加载后不会加载第二次\n    if (installedChunkData !== 0) {\n      var promise = new Promise(function (resolve, reject) {\n        installedChunkData = installedChunks[chunkId] = [resolve, reject]\n      })\n\n      promises.push(installedChunkData[2] = promise);\n\n      var script = document.createElement(\'script\')\n      script.src = chunkId + \'.bundle.js\'\n      document.head.appendChild(script)\n    }\n\n\n    return Promise.all(promises)\n\n\n  }\n\n\n  var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];\n\n  //核心是push方法\n  jsonpArray.push = webpackJsonpCallback;\n\n\n  // 异步加载的模块结构如下\n\n(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["say"], {\n\n  "./src/say.js":\n    (function (module, exports) {\n      module.exports = \'say import \';\n    })\n\n}]);\n\n//该模块被加载就会执行push方法，也就是执行webpackJsonpCallback\n\n// webpackJsonpCallback 接收一个data参数\n// data形如 [[chunkId1,chunkId2],{}]\n  function webpackJsonpCallback(data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n\n    var moduleId, chunkId, i resolves = [];\n    for ( var = 0; i < chunkIds.length; i++) {\n         chunkId = chunkIds[i];\n         //存储resolves回调数组\n        resolves.push(installedChunks[chunkId][0]);//[resolve,reject,promise]\n      }\n        //将所有加载后的chunkId标识为已加载\n      installedChunks[chunkId] = 0;\n    }\n\n  //将异步加载的模块与原模块合并，后续会在t函数内部执行一次webpack_require加载\n    for (moduleId in moreModules) {\n        modules[moduleId] = moreModules[moduleId];\n    }\n\n   //取出resolves回调数组并逐步执行\n    while (resolves.length) {\n      resolves.shift()();\n    }\n\n\n//t函数会加载异步合并的代码并进行esmodule和commonjs语法的兼容处理\n//经过t函数处理后的结果必然是一个带有default属性的对象\n//promsie中，返回的内容会在下一个then中获取\n\n// 默认进入时mode是7\n // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  __webpack_require__.t = function (value, mode) {\n\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if ((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, \'default\', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != \'string\'){\n      for (var key in value){\n         __webpack_require__.d(ns, key,\n          function (key) { return value[key]; }.bind(null, key)\n          );\n      }\n      \n    } \n    return ns;\n  };\n\n\n  };\n\n\n')),Object(a.b)("p",null,"关键部分已经给出注释，但可能细节上还需要动手多测试，验证。"),Object(a.b)("h2",null,"loader"),Object(a.b)("h3",null,"loader概述"),Object(a.b)("p",null,"webpack本身只能处理js文件，loader就是扩展webpack打包能力用的，\n告诉它非js格式文件该怎么处理。比如css相关的style-loader,css-loader。"),Object(a.b)("p",null,"loader其实和node中的pipe很像，如同流水线，一个loader之后可以接另一个loader。\n但最终，必须是一个js形式收尾。"),Object(a.b)("h3",null,"实现一个简易loader"),Object(a.b)("p",null,"loader的本质是一个函数，该函数通过source参数接收输入，通过返回值输出。\n下面以一个markdown-loader为例，举例说明一个loader是如何实现的。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const marked = require('marked')\nmodule.exports = source => {\n  const html = marked(source)\n  return  `module.exports = ${JSON.stringify(html)}`\n}\n")),Object(a.b)("p",null,"这就完事了？是的，就是如此简单。\n测试的话，这个loader可以在webpack的配置文件中以本地路径形式加载。"),Object(a.b)("h2",null,"plugin"),Object(a.b)("h3",null,"plugin概述"),Object(a.b)("p",null,"Webpack 的插件本质就是各种钩子，这就像组件生命周期一样，不同阶段存在不同钩子函数。\nwebpack赋予了这些钩子函数特定的能力，直接拿过来用就行了。"),Object(a.b)("h3",null,"实现一个简易plugin"),Object(a.b)("p",null,"plugin可以写成一个类的形式，然后身上有个apply方法，这个是webpack约定好的。\n下面写一个简单的小插件，用于打印构建过程涉及的文件名。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"class GetFileListPlugin {\n    apply(compiler) {\n        compiler.hooks.emit.tap('GetFileListPlugin ', compilation => {\n            // compilation => 可以理解为此次打包的上下文\n            for (const name in compilation.assets) {\n                console.log(name)\n                const contents = compilation.assets[name].source()\n                compilation.assets[name] = {\n                    //用于返回新内容 \n                    source: () => contents,\n                    //返回内容大小\n                    size: () => noComments.length\n                }\n            }\n        })\n\n    }\n}\n\nmodule.exports = GetFileListPlugin\n\n")),Object(a.b)("h2",null,"源码压缩包"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/lengyuexin/code"}),"https://github.com/lengyuexin/code"))),Object(a.b)("h2",null,"再会"),Object(a.b)("p",null,"情如风雪无常,"),Object(a.b)("p",null,"却是一动既殇。"),Object(a.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(a.b)("p",null,"我是冷月心,下期再见。"))}u.isMDXComponent=!0},BiVN:function(e,n,t){},EsZP:function(e,n,t){},Hv6d:function(e,n,t){"use strict";var l=t("KPh1"),a=t("qRUh"),r=t("xwgP"),o=t.n(r),s=t("Wbzz"),c=t("d33t"),u=t.n(c),i=(t("vPK/"),t("Zttt")),d=t("EYWl"),p=t("JLKy"),b=t("k7Sn"),m=function(e){return b.supportedLanguages[e].replace(/ /g," ")},h=function(e){function n(){return e.apply(this,arguments)||this}return Object(a.a)(n,e),n.prototype.render=function(){var e=this.props,n=e.translations,t=e.lang,l=e.languageLink,a=e.editUrl;return o.a.createElement("div",{className:"translations"},o.a.createElement(p.a,{style:{fontFamily:'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",\n    "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans",\n    "Droid Sans", "Helvetica Neue", sans-serif'}},n.length>0&&o.a.createElement(o.a.Fragment,null,o.a.createElement("span",null,"Translated by readers into: "),n.map((function(e,a){return o.a.createElement(o.a.Fragment,{key:e},e===t?o.a.createElement("b",null,m(e)):o.a.createElement(s.Link,{to:l(e)},m(e)),a===n.length-1?"":" • ")}))),"zh-hans"!==t&&o.a.createElement(o.a.Fragment,null,o.a.createElement("br",null),o.a.createElement("br",null),o.a.createElement(s.Link,{to:l("zh-hans")},"Read the original")," • ",o.a.createElement("a",{href:a,target:"_blank",rel:"noopener noreferrer"},"Improve this translation")," • ",o.a.createElement(s.Link,{to:"/"+t},"View all translated posts")," ")))},n}(o.a.Component),f=t("L6NH"),j=t("p3AD");function k(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function g(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?k(Object(t),!0).forEach((function(n){Object(l.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):k(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var O=function(e){function n(){return e.apply(this,arguments)||this}return Object(a.a)(n,e),n.prototype.render=function(){console.log(this.props);var e=this.props,n=e.pageContext,l=e.children,a=e.location,r=e.previous,c=e.next,p=e.translations,b=u()(this.props,"queryData.site.siteMetadata.title"),k=n.langKey,O=n.slug;p&&(p=p.slice()).sort((function(e,n){return m(e)<m(n)?-1:1})),function(e){switch(e){case"ru":case"bg":t("EsZP"),t("s85H");break;case"uk":t("EsZP"),t("s85H"),t("Mq6Z"),t("e/YJ");break;case"cs":case"da":case"de":case"es":case"fi":case"fr":case"he":case"hu":case"it":case"nl":case"no":case"pl":case"pt-br":case"sk":case"sr":case"sq":case"sv":case"tr":t("Mq6Z"),t("e/YJ");break;case"vi":t("Vjog"),t("Pf5Y");break;case"fa":t("BiVN");break;case"ar":t("xpFW")}}(k);var _=function(e,n){var t=e.replace(n+"/","");return function(e){return"zh-hans"===e?t:""+e+t}}(O,k),v=_("en"),w="https://github.com/gaearon/overreacted.io/edit/master/src/pages/"+v.slice(1,v.length-1)+"/index"+("zh-hans"===k?"":"."+k)+".md";return o.a.createElement(i.a,{location:a,title:b},o.a.createElement(d.a,{lang:k,title:n.frontmatter.title,description:n.frontmatter.spoiler,slug:O,date:n.frontmatter.date}),o.a.createElement("div",{style:{marginLeft:"auto",marginRight:"auto",maxWidth:Object(j.a)(24)}},o.a.createElement("article",null,o.a.createElement("header",null,o.a.createElement("h1",{style:{color:"var(--textTitle)"}},n.frontmatter.title),o.a.createElement("p",{style:g(g({},Object(j.b)(-.2)),{},{display:"block",marginBottom:Object(j.a)(1),marginTop:Object(j.a)(-.8)})},Object(f.a)(n.frontmatter.date,k)),p&&p.length>0&&o.a.createElement(h,{translations:p,editUrl:w,languageLink:_,lang:k})),o.a.createElement("div",null,l)),o.a.createElement("aside",null,o.a.createElement("nav",null,o.a.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},o.a.createElement("li",null,r&&o.a.createElement(s.Link,{to:r.fields.slug,rel:"prev",style:{marginRight:20}},"← ",r.frontmatter.title)),o.a.createElement("li",null,c&&o.a.createElement(s.Link,{to:c.fields.slug,rel:"next"},c.frontmatter.title," →")))))))},n}(o.a.Component);n.a=function(e){return o.a.createElement(s.StaticQuery,{query:"2199005656",render:function(n){return o.a.createElement(O,Object.assign({queryData:n},e))}})}},Mq6Z:function(e,n,t){},Pf5Y:function(e,n,t){},Vjog:function(e,n,t){},"e/YJ":function(e,n,t){},k7Sn:function(e,n){n.supportedLanguages={en:"English","zh-hans":"简体中文"}},s85H:function(e,n,t){},shca:function(e,n,t){"use strict";function l(e,n){if(null==e)return{};var t,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)t=r[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}t.d(n,"a",(function(){return l}))},"vPK/":function(e,n,t){},xpFW:function(e,n,t){}}]);
//# sourceMappingURL=component---src-pages-webpack-index-mdx-731682c65d29a83a2504.js.map