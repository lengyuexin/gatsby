(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{"+5hD":function(n,e,t){"use strict";t.r(e),t.d(e,"_frontmatter",(function(){return s})),t.d(e,"default",(function(){return r}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var a=t("7ljp"),i=t("Hv6d");var s={},o={_frontmatter:s},l=i.a;function r(n){var e=n.components,t=function(n,e){if(null==n)return{};var t,a,i={},s=Object.keys(n);for(a=0;a<s.length;a++)t=s[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,["components"]);return Object(a.b)(l,Object.assign({},o,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"前言"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://www.npmjs.com/package/react-grid-layout"}),"react-grid-layout"),"是基于react的网格布局系统，支持视图的拖拽和缩放，操作十分灵活。"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://react-grid-layout.github.io/react-grid-layout/examples/0-showcase.html"}),"在线体验"),"。"),Object(a.b)("p",null,"工作中某个项目模块实现用到了react-grid-layout，就去看了一下核心功能的实现。"),Object(a.b)("p",null,"实际上，这篇文章也是内部串讲的一部分，有时间会单独分享一下做串讲的经验。"),Object(a.b)("p",null,"不得不说，作者的思维很巧妙，一阵连环套娃。"),Object(a.b)("p",null,"今天我们就来看一下这个库的核心功能实现，包括网格布局计算、拖动、缩放。"),Object(a.b)("p",null,"东西比较多，可选读。"),Object(a.b)("p",null,"整体结构图和核心功能实现原理如下："),Object(a.b)("p",null,Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/815f9a0c48a3485daeedfdc02bdd2044~tplv-k3u1fbpfcp-zoom-1.image",alt:null})),"\n",Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5af133d2354b438109b8ce9bd830f9~tplv-k3u1fbpfcp-zoom-1.image",alt:null}))),Object(a.b)("h2",null,"基本使用"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"可以看到，只需要传递一个带有布局信息的layout数组即可")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import React from 'react';\nimport GridLayout from 'react-grid-layout';\nexport default class App extends React.PureComponent {\n  render() {\n    // layout is an array of objects\n    // static 表示不可拖动和缩放 \n    // key是必须的\n    const layout = [\n      { i: 'a', x: 0, y: 1, w: 1, h: 1, static: true },\n      { i: 'b', x: 1, y: 0, w: 3, h: 2 },\n      { i: 'c', x: 4, y: 0, w: 1, h: 2 },\n    ];\n    return (\n      <GridLayout layout={layout} width={1200}>\n        <div key=\"a\">a</div>\n        <div key=\"b\">b</div>\n        <div key=\"c\">c</div>\n      </GridLayout>\n    );\n  }\n}\n")),Object(a.b)("h2",null,"网格布局"),Object(a.b)("p",null,"接下来进入react-grid-layout最为关键的部分，网格布局生成和计算。\n简单来说就是根据用户给定的layout，计算出带有px的具体样式，最终展现在页面上。\n我们直接看源码中入口组件ReactGridLayout中的render函数："),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"render() {\n    const { className, style, isDroppable, innerRef } = this.props;\n    // 合并类名\n    const mergedClassName = classNames(layoutClassName, className);\n    // 合并style\n    const mergedStyle = {\n      height: this.containerHeight(),// 计算容器高度\n      ...style,\n    };\n    // 绑定drag和drop事件，其中noop是一个空函数\n    // export const noop = () => {};\n    return (\n      <div\n        ref={innerRef}\n        className={mergedClassName}\n        style={mergedStyle}\n        // 拖拽相关的一些回调，如果业务场景不需要，可以不设置\n        // 默认isDroppable是false\n        onDrop={isDroppable ? this.onDrop : noop}\n        onDragLeave={isDroppable ? this.onDragLeave : noop}\n        onDragEnter={isDroppable ? this.onDragEnter : noop}\n        onDragOver={isDroppable ? this.onDragOver : noop}\n      >\n          // 渲染节点\n        {React.Children.map(\n            this.props.children, \n            child => this.processGridItem(child)\n        )}\n        \n        // 暂且可忽略，默认isDroppable 是false\n        {isDroppable && \n         this.state.droppingDOMNode && \n         this.processGridItem(this.state.droppingDOMNode, true)}\n        // 在拖拽时候展示操纵蒙版\n        {this.placeholder()}\n      </div>\n    );\n  }\n")),Object(a.b)("p",null,"render中做了三件关键的事："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"合并样式和类名"),Object(a.b)("li",{parentName:"ul"},"绑定拖拽事件"),Object(a.b)("li",{parentName:"ul"},"渲染Children")),Object(a.b)("h3",null,"渲染Children"),Object(a.b)("p",null,"我们先来看渲染Children这部分，函数processGridItem内部用GridItem组件对传入的react元素做了一层包裹后返回。其中GridItem是网格单元的展示组件，它接收布局，拖动，缩放等相关props。关于GridItem更多细节，下面会提到。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"processGridItem(\n    child: ReactElement<any>,\n    isDroppingItem?: boolean\n  ): ?ReactElement<any> {\n   // 这里也有一个小细节，如果传入的child没有key,会被return掉，不会在页面上展示。\n    if (!child || !child.key) return;\n    // 布局相关\n    const l = getLayoutItem(this.state.layout, String(child.key));\n    if (!l) return null;\n     // xxx... \n    return (\n      <GridItem\n    //... 布局 拖动 缩放 相关props\n      >\n        {child}\n      </GridItem>\n    );\n  }\n")),Object(a.b)("p",null,"接下来，我们看下布局和相关的东西。上述getLayoutItem函数接收一个来自内部state的参数layout。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"  state = {\n    activeDrag: null,\n    layout: synchronizeLayoutWithChildren(\n      this.props.layout,// 包含布局信息的数组对象\n      this.props.children,// react元素\n      this.props.cols,// 布局列数 默认12 \n      // 控制水平/垂直布局\n      compactType(this.props)\n    ),\n    mounted: false,\n    oldDragItem: null,\n    oldLayout: null,\n    oldResizeItem: null,\n    droppingDOMNode: null,\n    children: []\n  };\n")),Object(a.b)("p",null,"state中对layout做了一个处理，涉及到了函数synchronizeLayoutWithChildren。"),Object(a.b)("h3",null,"synchronizeLayoutWithChildren"),Object(a.b)("p",null,"该函数见名知义，用于同步layout和children，为每个child生成一个网格布局单元。对于已有布局(传入的layout中每项的i和child的key匹配上)，直接使用。如果没有layout参数，看child上是否有_grid和data-grid属性，有的话就使用，效果和layout参数一致。如果上述提到的布局相关的参数都没有，会创建一个默认布局,添加到已有布局的下方。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),' function synchronizeLayoutWithChildren(\n  initialLayout: Layout,\n  children: ReactChildren,\n  cols: number,\n  compactType: CompactType\n): Layout {\n  initialLayout = initialLayout || [];\n  const layout: LayoutItem[] = [];\n  React.Children.forEach(children, (child: ReactElement<any>, i: number) => {\n    // 已有布局直接复用，其实就是一个find操作\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n     // _grid的废弃警告，建议使用layout或者data-grid传递布局信息\n     // xxx..\n      }\n      const g = child.props["data-grid"] || child.props._grid;\n      // 如果child有data-grid或者_grid属性直接使用\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], "ReactGridLayout.children");\n        }\n        layout[i] = cloneLayoutItem({ ...g, i: child.key });\n      } else {\n        //创建一个默认布局\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  });\n\n  //  边界处理/防堆叠\n  const correctedLayout = correctBounds(layout, { cols: cols });\n  // 空间压缩\n  return compact(correctedLayout, compactType, cols);\n}\n')),Object(a.b)("p",null,"props传递进来的layout，或者人为拖动/缩放的布局，都有可能发生一些小冲突，比如堆叠，越界。\n所以在最后需要对布局进行一些额外处理：如越界修正，防堆叠，压缩额外空间使布局紧凑。"),Object(a.b)("h3",null,"correctBounds"),Object(a.b)("p",null,"边界控制函数，对于给定的布局，确保每一个都在其边界限制内。\n如果是右侧越界，新的x坐标=布局列数-列宽。\n如果是左侧越界，新的x坐标为0，列宽= 布局列数。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"//cols 网格列数 默认12\nfunction correctBounds(layout: Layout, bounds: { cols: number }): Layout {\n // 获取静态item ，static =true\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // 右侧溢出处理 \n    if (l.x + l.w > bounds.cols) {\n      l.x = bounds.cols - l.w;\n    }\n    // 左侧溢出处理\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) {\n      collidesWith.push(l);\n    } else {\n   // 如果静态元素碰撞，首项下移，避免堆叠\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n\nfunction getFirstCollision(\n  layout: Layout,\n  layoutItem: LayoutItem\n): ?LayoutItem {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\n")),Object(a.b)("h3",null,"碰撞检测函数"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"function collides(l1, l2){\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n")),Object(a.b)("h3",null,"compact"),Object(a.b)("p",null,"该函数用于对布局空间进行压缩，使布局更紧凑。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),' function compact(layout, compactType, cols) {\n   // 获取静态布局   static =true\n  const compareWith = getStatics(layout);\n  // 根据传入的压缩方式进行排序 \n  // 水平或者垂直 \'horizontal\' | \'vertical\';\n  const sorted = sortLayoutItems(layout, compactType);\n  // 用于放置新布局的数组\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n    // 不会移动静态元素\n    if (!l.static) {\n        // 压缩空间\n      l = compactItem(compareWith, l, compactType, cols, sorted);\n      compareWith.push(l);\n    }\n    // Add to output array \n    // to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n\n  return out;\n}\n\n\n// 压缩处理函数\nfunction compactItem(\n  compareWith: Layout,\n  l: LayoutItem,\n  compactType: CompactType,\n  cols: number,\n  fullLayout: Layout\n): LayoutItem {\n  const compactV = compactType === "vertical";\n  const compactH = compactType === "horizontal";\n  if (compactV) {\n     // 垂直方向不发生碰撞情况下 压缩y坐标\n    l.y = Math.min(bottom(compareWith), l.y);\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // 水平方向不发生碰撞情况下 压缩x坐标\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // 发生碰撞就下移或者左移\n  let collides;\n  while ((collides = getFirstCollision(compareWith, l))) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, "x");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, "y");\n    }\n    // 控制水平方向上的无限增长.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n  \n  // 对上述的y--,x--做容错处理，确保没有负值\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  \n  return l;\n}\n')),Object(a.b)("p",null,"经过correntBounds和compact函数处理，就会生成一个紧凑，无溢出，无堆叠效果的网格布局单元。"),Object(a.b)("h3",null,"容器高度计算"),Object(a.b)("p",null,"说完了布局生成，再来看一下入口组件render函数中对类名和样式的处理。类名合并上没什么特别的，直接使用",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://www.npmjs.com/package/classnames"}),"classnames"),"进行合并。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"// classnames 基本使用\nvar classNames = require('classnames');\nclassNames('foo', 'bar'); // => 'foo bar'\n// react-grid-layout中使用\nconst { className, style, isDroppable, innerRef } = this.props;\n// 合并类名\nconst mergedClassName = classNames(layoutClassName, className);\n")),Object(a.b)("p",null,"样式合并涉及到了一个用于计算容器高度的函数containerHeight，这里还是有一些值得说的点。一个容器的高度至少要容纳最高占位布局(高度h和位置y),所以需要从给定的布局中找出h+y最大的那一项，作为容器基准高度。如下图所示，为便于观察，每一个布局项高度h都是1,最大的y轴坐标为2，容器基准高度就是3.\n",Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e7fa047d41e4b0893dbc922ab44c127~tplv-k3u1fbpfcp-zoom-1.image",alt:null})),"\n但是完整的高度不仅仅是基准高度，还涉及到grid-item之间的margin,容器纵向padding。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"containerHeight() {\n    // 默认autoSize是true\n    if (!this.props.autoSize) {\n      return;\n    }\n    // 获取底部坐标\n    // 这里的layout是经过修正的，不同于this.props.layout\n    const nbRow = bottom(this.state.layout);\n    const containerPaddingY = this.props.containerPadding \n    ? this.props.containerPadding[1] \n    : this.props.margin[1];\n    \n   // 计算成具体的px\n   // rowHeight默认150 margin默认[10,10]\n    return `\n    ${nbRow * this.props.rowHeight +\n     (nbRow - 1) * this.props.margin[1] + \n     containerPaddingY * 2 }\n     px`;\n  }\n  \n  // 获取布局中y+h的最大值\n function bottom(layout: Layout): number {\n  let max = 0;\n  let bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) {\n      max = bottomY;\n    }\n  }\n  return max;\n}\n")),Object(a.b)("p",null,"上述布局计算结果：30(rowHeight)*3(基准高度)+20(2个margin)+20(上下容器padding)=130px。值得注意的是: 计算容器高度的时候，基准高度指的是经过compact函数压缩后的坐标值。来看一个具体的高度计算案例："),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"export default class App extends React.PureComponent {\n  render() {\n    const layout = [\n      { i: 'a', x: 0, y: 100, w: 1, h: 1 },\n    ];\n    return (\n      <div style={{ width: 600, border: '1px solid #ccc', margin: 10 }}>\n        <GridLayout layout={layout} width={600}>\n          <div key=\"a\">a</div>\n        </GridLayout>\n      </div>\n    );\n  }\n}  \n")),Object(a.b)("p",null,Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feff902f8c124384b526b33554e61a8a~tplv-k3u1fbpfcp-zoom-1.image",alt:null})),"\n在containerHeight内部打印一下，会发现y并不是传入的100，而是被compact压缩后的0。如此一来，容器的基准高度就是 h+y=1+0=1。容器高度= 150(rowHeight)*1(基准高度)+0(margin)+20(上下容器padding)=170px。"),Object(a.b)("h2",null,"GridItem"),Object(a.b)("p",null,"上述是容器布局计算，网格单元的计算是在GridItem组件组件进行的。\n该组件接受的props比较多,大致分为布局，拖动，缩放这三类。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"})," processGridItem(child: any, isDroppingItem?: boolean): any {\n    if (!child || !child.key) {\n      return;\n    }\n    const l = getLayoutItem(this.state.layout, String(child.key));\n    if (!l) {\n      return null;\n    }\nconst {\n  width,// 容器宽度\n  cols, // 布局列数 默认12\n  margin, // Margin between items [x, y] in px\n  containerPadding, // Padding inside the container [x, y] in px\n  rowHeight, // 单个grid-item高度\n  maxRows,// 最大行数 默认无限 表现为infinite vertical growth\n  isDraggable, // 是否可拖动 默认true\n  isResizable, // 是否可缩放  默认true\n  isBounded,  // 控制是否在容器限制内移动 默认false \n  useCSSTransforms,//默认为true,开启后使用transforms替代left/top,绘制性能提高6倍\n  transformScale, // 比例系数 默认1 transform: scale(n)\n  draggableCancel, // 取消拖动手柄 css类名选择器\n  draggableHandle,// 拖动手柄 css类名选择器\n  resizeHandles,// 缩放方位 默认se 右下角\n  resizeHandle, // 缩放手柄\n} = this.props;\n    \nconst { mounted, droppingPosition } = this.state;\n// 判断是否可拖动/缩放\nconst draggable = typeof l.isDraggable === 'boolean' ? \nl.isDraggable : \n!l.static && isDraggable;\nconst resizable = typeof l.isResizable === 'boolean' ? \nl.isResizable : \n!l.static && isResizable;\n\n// 判断缩放方向 默认se \nconst resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n// 判断是否限制在容器内移动\nconst bounded = draggable && isBounded && l.isBounded !== false;\n\n    return (\n      <GridItem\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={containerPadding || margin}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        cancel={draggableCancel}\n        handle={draggableHandle}\n        onDragStop={this.onDragStop}\n        onDragStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n        onResizeStop={this.onResizeStop}\n        isDraggable={draggable}\n        isResizable={resizable}\n        isBounded={bounded}\n        useCSSTransforms={useCSSTransforms && mounted}\n        usePercentages={!mounted}\n        transformScale={transformScale}\n        w={l.w}\n        h={l.h}\n        x={l.x}\n        y={l.y}\n        i={l.i}\n        minH={l.minH}\n        minW={l.minW}\n        maxH={l.maxH}\n        maxW={l.maxW}\n        static={l.static}\n        droppingPosition={isDroppingItem ? droppingPosition : undefined}\n        resizeHandles={resizeHandlesOptions}\n        resizeHandle={resizeHandle}\n      >\n        {child}\n      </GridItem>\n    );\n  }\n")),Object(a.b)("h3",null,"Render"),Object(a.b)("p",null,"接下来，我们看一下这个组件的render函数具体做了些什么。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"render() {\n    const { \n    x, y, w, h, \n    isDraggable, \n    isResizable, \n    droppingPosition,\n    useCSSTransforms \n   } = this.props;\n    // 位置计算，触发拖动和缩放时候也会重新计算\n    const pos =calcGridItemPosition(\n     this.getPositionParams(), \n     x, y, w, h,\n     this.state\n     );\n   // 获取 child \n    const child= React.Children.only(this.props.children);\n\n    // 修改child的类名和样式\n    let newChild = React.cloneElement(child, {\n      ref: this.elementRef,\n      // 修改类名\n      className: classNames(\n      'react-grid-item', \n       child.props.className, \n       this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        'react-draggable': isDraggable,\n        'react-draggable-dragging': Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms,\n      }),\n      // 修改样式\n      // 真正将网格单元w，h，x，y换成带有px的具体尺寸\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos),\n      },\n    });\n\n    // 添加缩放支持\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n    // 添加拖动支持\n    newChild = this.mixinDraggable(newChild, isDraggable);\n\n    return newChild;\n  }\n  \n  \n getPositionParams(props: Props = this.props): PositionParams {\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n")),Object(a.b)("h3",null,"calcGridItemPosition"),Object(a.b)("p",null,"该函数接收布局相关参数，经过一系列计算，返回最终的计算结果。\n给定参数如下："),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{}),"{ i: 'a', x: 0, y: 0, w: 2, h: 1, } 容器宽度600，\n网格间margin10,\n容器paadding10,\n列数cols12\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"计算原理")),Object(a.b)("p",null,"列宽的计算和之前算高度是类似的，也要考虑网格间的margin和容器的padding(左右)。\n列宽colWidth = (containerWidth - margin","[0]"," ",Object(a.b)("em",{parentName:"p"}," (cols - 1) - containerPadding","[0]"," ")," 2) / cols\n以上述布局为例,计算出来的列宽经过四舍五入后是39，但这个是基于布局单元计算的。\n如果gridItem正在缩放，就采用缩放时state记录的宽高(width,height)。\n如果gridItem正在拖拽，就采用拖拽时state记录的位置(left,top)。\n注意:react-grid-layout里margin存储的是","[x,y]","形式，与css中margin设置两个值时候效果是相反的。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"function calcGridItemPosition(\n  positionParams,\n  x,\n  y,\n  w,\n  h,\n  state\n){\n  const { margin, containerPadding, rowHeight } = positionParams;\n  // 计算列宽\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // 如果gridItem正在缩放，就采用缩放时state记录的宽高(width,height)。\n  // 通过回调函数获取布局信息\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // 反之，基于网格单元计算\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // 如果gridItem正在拖拽，就采用拖拽时state记录的位置(left,top)\n  // 通过回调函数获取布局信息\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  }\n  // 反之，基于网格单元计算\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n\n  return out;\n}\n// 计算列宽\nfunction calcGridColWidth(positionParams: PositionParams): number {\n  const { margin, containerPadding, containerWidth, cols } = positionParams;\n  return (\n    (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols\n  );\n}\n// gridUnits 网格布局基准单元\nfunction calcGridItemWHPx(gridUnits, colOrRowSize, marginPx){\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(\n  colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n")),Object(a.b)("h3",null,"createStyle"),Object(a.b)("p",null,"说完了布局宽高和位置计算，再来看一下对样式的处理。\ngridItem样式合并中用到了函数createStyle,可以将计算好的布局转成带px的css样式。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'createStyle(pos) {\n    const { usePercentages, containerWidth, useCSSTransforms } = this.props;\n    let style;\n    // 支持 CSS Transforms 默认\n    // 直接跳过布局和绘制，且不占用主线程资源，比较快\n    if (useCSSTransforms) {\n      style = setTransform(pos);\n    } else {\n      // 使用 top,left 展示，会比较慢\n      style = setTopLeft(pos);\n      // 服务端渲染相关\n      if (usePercentages) {\n        style.left = perc(pos.left / containerWidth);\n        style.width = perc(pos.width / containerWidth);\n      }\n    }\n\n    return style;\n  }\n  \n  // 采用 translate 形式 并添加兼容处理和单位px\n  function setTransform({ top, left, width, height }) {\n      const translate = `translate(${left}px,${top}px)`;\n      return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: "absolute"\n      };\n}\n\n// 采用 left top 形式 并添加单位px\nfunction setTopLeft({ top, left, width, height } {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: "absolute"\n  };\n}\n')),Object(a.b)("h2",null,"拖拽和缩放"),Object(a.b)("h3",null,"mixinDraggable"),Object(a.b)("p",null,"mixinDraggable函数为child添加拖动支持，实现上依赖react-draggable。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"拖拽原理")),Object(a.b)("p",null,"在react-draggable库的DraggableCore组件内部，触发相应拖拽事件时会生成一些有用的信息，比如坐标，当前节点。这个信息会被封装成对象，作为参数传递给外部对应的回调函数。这样一来，外部回调就可以从这个对象中获取有用信息，重新setState，将dragging的值设置为新的{left,top}。然后这个值会经过函数calcGridItemPosition和createStyle处理，作为css样式附加在child上，从而实现拖拽。"),Object(a.b)("p",null,Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf64b4d4a5a343d2807c5099b2f33295~tplv-k3u1fbpfcp-zoom-1.image",alt:null}))),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"})," import { DraggableCore } from 'react-draggable';\n  function mixinDraggable(child, isDraggable) {\n  // 下面这些拖拽相关的回调函数用于接收额外的位置信息，计算布局\n    return (\n      <DraggableCore\n        disabled={!isDraggable}\n        onStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onStop={this.onDragStop}\n        handle={this.props.handle}\n        cancel={`.react-resizable-handle${ this.props.cancel ?\n         `,${ this.props.cancel}` : ''}`}\n        scale={this.props.transformScale}\n        nodeRef={this.elementRef}\n      >\n        {child}\n      </DraggableCore>\n    );\n  }\n  \n")),Object(a.b)("h3",null,"DraggableCore"),Object(a.b)("p",null,"在react-grid-layout中，不论是mixinDraggable还是mixinResizable都会依赖组件DraggableCore。这是因为拖动和缩放都会涉及相同的鼠标事件(暂不考虑触摸事件)，对此，该组件也封装了相应的事件处理函数函数。在这三个函数内部，会调用props中传入的回调函数onStart，onDrag，onStop。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"handleDragStart 拖拽开始：记录拖拽的初始位置 "),Object(a.b)("li",{parentName:"ul"},"handleDrag 拖拽中：监听拖拽的距离和方向，并移动真实 dom"),Object(a.b)("li",{parentName:"ul"},"handleDragStop 拖拽结束：取消拖拽中的事件监听")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"render() {\n    return React.cloneElement(React.Children.only(this.props.children), {\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // xxx..触摸相关事件\n    });\n  }\n  \n  \n // dragEventFor 是一个用于标识触发事件类型的全局变量 鼠标 or 触摸\n onMouseDown = (e) => {\n  // 鼠标相关事件\n    dragEventFor ={\n         start: 'mousedown',\n         move: 'mousemove',\n         stop: 'mouseup'\n    }\n    return this.handleDragStart(e);\n };\n \nhandleDragStart(){\n//...\nthis.props.onStart()\n}\n\nhandleDrag(){\n//...\nthis.props.onDrag()\n}\n\nhandleDragStop(){\n//...\nthis.props.onStop()\n}\n")),Object(a.b)("p",null,"接下来我们来逐一看下这几个事件处理函数的内部操作细节。"),Object(a.b)("h3",null,"handleDragStart"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'  handleDragStart = (e) => {\n    // 支持鼠标按下的回调函数\n    this.props.onMouseDown(e);\n\n    // Only accept left-clicks.\n    //xxx...\n    \n    // 确保获取到document\n   // https://developer.mozilla.org/zh-CN/docs/Web/API/Node/ownerDocument\n    const thisNode = this.findDOMNode();\n    if (!thisNode ||\n     !thisNode.ownerDocument ||\n     !thisNode.ownerDocument.body) {\n      throw new Error(\'<DraggableCore> not mounted on DragStart!\');\n    }\n    const {ownerDocument} = thisNode;\n\n   \nif (this.props.disabled ||\n  (!(e.target instanceof ownerDocument.defaultView.Node)) ||\n  (this.props.handle && \n  !matchesSelectorAndParentsTo(e.target, this.props.handle, thisNode)) ||\n  (this.props.cancel && \n  matchesSelectorAndParentsTo(e.target, this.props.cancel, thisNode))) {\n  return;\n}\n\n/**操作手柄示例\n\x3c!--实际上可以没有对应的css样式handle--\x3e\n<Draggable handle=".handle">\n  <div>\n      <div className="handle">Click me to drag</div>\n      <div>This is some other content</div>\n  </div>\n</Draggable>*/\n\n\n    // 触摸相关操作 ...\n    // 非触摸设备，getControlPosition第二个函数为undefined\n    // 获取鼠标按下时候的坐标\n    const position = getControlPosition(e, undefined, this);\n    if (position == null) return; \n    const {x, y} = position;\n    \n   // 包含节点自身，坐标和其他信息的对象\n    const coreEvent = createCoreData(this, x, y);\n    // 调用props传入的回调 onStart\n    const shouldUpdate = this.props.onStart(e, coreEvent);\n    if (shouldUpdate === false || this.mounted === false) return;\n    // 更新拖拽状态并存储偏移量 \n    this.setState({\n      dragging: true,\n      lastX: x,\n      lastY: y\n    });\n\n   // 将move事件绑定在document上，扩大响应范围\n   // 这样即使移出当前griditem 依旧能保证事件得到响应。\n   // 可触摸设备和非可触摸设备结束拖拽时候的响应事件不同，这里需要用两个事件\n    addEvent(ownerDocument, dragEventFor.move, this.handleDrag);\n    addEvent(ownerDocument, dragEventFor.stop, this.handleDragStop);\n  };\n')),Object(a.b)("h3",null,"handleDrag"),Object(a.b)("p",null,"在看完handleDragStart函数内部细节后，handleDrag和handleDragStop都会好理解些。\nhandleDrag主要做的事情是在拖动过程中不断更新位置信息。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"  handleDrag=(e) => {\n    // Get the current drag point from the event. This is used as the offset.\n    const position = getControlPosition(e, null, this);\n    if (position == null) return;\n    let {x, y} = position;\n    const coreEvent = createCoreData(this, x, y);\n    // Call event handler. If it returns explicit false, trigger end.\n    const shouldUpdate = this.props.onDrag(e, coreEvent);\n    if (shouldUpdate === false || this.mounted === false) {\n      try {\n        this.handleDragStop(new MouseEvent('mouseup'));\n      } catch (err) {\n        // Old browsers\n        //xxx... 旧浏览器的一些兼容处理\n      }\n      return;\n    }\n\n    this.setState({\n      lastX: x,\n      lastY: y\n    });\n  };\n")),Object(a.b)("h3",null,"handleDropStop"),Object(a.b)("p",null,"拖拽结束，重置位置信息，删除绑定的事件处理函数。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\n  handleDragStop= (e) => {\n    if (!this.state.dragging) return;\n\n    const position = getControlPosition(e, this.state.touchIdentifier, this);\n    if (position == null) return;\n    const {x, y} = position;\n    const coreEvent = createCoreData(this, x, y);\n\n    // Call event handler\n    const shouldContinue = this.props.onStop(e, coreEvent);\n    if (shouldContinue === false || this.mounted === false) return false;\n\n    const thisNode = this.findDOMNode();\n    // Reset the el.\n    this.setState({\n      dragging: false,\n      lastX: NaN,\n      lastY: NaN\n    });\n\n    if (thisNode) {\n      // Remove event handlers\n      removeEvent(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n      removeEvent(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n    }\n  };\n")),Object(a.b)("h3",null,"mixinResizable"),Object(a.b)("p",null,"mixinResizable函数为child添加缩放支持，实现上依赖react-resizable。\nreact-resizable的实现又依赖了react-draggable。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"缩放原理")),Object(a.b)("p",null,"缩放和拖拽底层依赖的是同一个库，这就注定了在功能实现上是类似的思路，都是借助回调函数。DraggableCore组件内部将包含位置信息的事件对象传递给外部回调函数，回调中会重新setState,将resizing的值设置为新的{width,height}。最后，获取到的新的width,height会通过css样式作用在grid-item上,从而实现缩放功能。\n",Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d64264bcb2c45458df9578c74e6e55d~tplv-k3u1fbpfcp-zoom-1.image",alt:null}))),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'function mixinResizable(child,position,isResizable) {\n    const {\n      cols,\n      x,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n    // 最大宽度\n    const maxWidth = calcGridItemPosition(positionParams, 0, 0, cols - x, 0)\n      .width;\n\n    // 计算最小网格布局和最大网格布局和对应的容器大小\n    const mins = calcGridItemPosition(positionParams, 0, 0, minW, minH);\n    const maxes = calcGridItemPosition(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [\n      Math.min(maxes.width, maxWidth),\n      Math.min(maxes.height, Infinity)\n    ];\n    return (\n      <Resizable\n        draggableOpts={{\n          disabled: !isResizable,\n        }}\n        className={isResizable ? undefined : "react-resizable-hide"}\n        width={position.width}\n        height={position.height}\n        minConstraints={minConstraints}\n        maxConstraints={maxConstraints}\n        onResizeStop={this.onResizeStop}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n        transformScale={transformScale}\n        resizeHandles={resizeHandles}\n        handle={resizeHandle}\n      >\n        {child}\n      </Resizable>\n    );\n  }\n')),Object(a.b)("h3",null,"Resizable"),Object(a.b)("p",null,"resizable组件主要做了3件事："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"传递resizable内部回调函数给DraggableCore组件，用于获取事件信息对象。"),Object(a.b)("li",{parentName:"ul"},"在resizable内部回调函数中将获取到的事件信息对象传递给外部回调，用于最终的样式更新，实际上是套了两层"),Object(a.b)("li",{parentName:"ul"},"渲染操控手柄")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"})," render() {\n    return cloneElement(children, {\n      ...p,\n      className: `${className ? `${className} ` : ''}react-resizable`,\n      children: [\n        ...[].concat(children.props.children),\n        // handleAxis 是一个存储操纵方位的数组 \n        ...resizeHandles.map((handleAxis) => {\n          // 挂载一个node节点 用于操控\n          const ref = this.handleRefs[handleAxis] ?\n           this.handleRefs[handleAxis] ： React.createRef();\n          return (\n            <DraggableCore\n              {...draggableOpts}\n              nodeRef={ref}\n              key={`resizableHandle-${handleAxis}`}\n              onStop={this.resizeHandler('onResizeStop', handleAxis)}\n              onStart={this.resizeHandler('onResizeStart', handleAxis)}\n              onDrag={this.resizeHandler('onResize', handleAxis)}\n            >\n            // 渲染不同方位的操控手柄，默认右下角 se\n              {this.renderResizeHandle(handleAxis, ref)}\n            </DraggableCore>\n          );\n        })\n      ]\n    });\n  }\n")),Object(a.b)("h3",null,"通用事件函数封装"),Object(a.b)("p",null,"缩放的三个事件处理函数在外部只做简单触发，内部共用一套处理逻辑(onResizeHandler)。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'  // 停止缩放\n  onResizeStop: (Event, { node: HTMLElement, size: Position }) => void = (\n    e,\n    callbackData\n  ) => {\n    this.onResizeHandler(e, callbackData, "onResizeStop");\n  };\n\n// 开始缩放\n  onResizeStart: (Event, { node: HTMLElement, size: Position }) => void = (\n    e,\n    callbackData\n  ) => {\n    this.onResizeHandler(e, callbackData, "onResizeStart");\n  };\n\n // 缩放中\n  onResize: (Event, { node: HTMLElement, size: Position }) => void = (\n    e,\n    callbackData\n  ) => {\n    this.onResizeHandler(e, callbackData, "onResize");\n  };\n')),Object(a.b)("h3",null,"onResizeHandler"),Object(a.b)("p",null,"该函数用于计算缩放后重新生成的网格单元信息，并将变更后的宽和高存储到state的resizing上。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),' onResizeHandler(\n    e: Event,\n    { node, size }: { node: HTMLElement, size: Position },\n    handlerName: string\n  ): void {\n   //根据传入的handler名称获取对应的事件处理函数\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const { cols, x, y, i, maxH, minH } = this.props;\n    let { minW, maxW } = this.props;\n\n    // 根据宽高计算出网格单元w,h\n    // 因为缩放是会改变大小的，大小改变对应的网格单元也要变\n    let { w, h } = calcWH(\n      this.getPositionParams(),\n      size.width,\n      size.height, \n      x,\n      y\n    );\n\n    // 最小应该保持一个单元的布局\n    minW = Math.max(minW, 1);\n    //最大(cols - x)\n    maxW = Math.min(maxW, cols - x);\n\n    // 限制宽高在min max之间，可以等于min max\n    w = clamp(w, minW, maxW);\n    h = clamp(h, minH, maxH);\n\n    // 更新reszing 的值，和dragging作用类似，用于最终的样式计算\n    // 差异是这里边只会存储width/height\n    // dragging 中会存储left/top\n    this.setState({ resizing: handlerName === "onResizeStop" ? null : size });\n\n    handler.call(this, i, w, h, { e, node, size });\n  }\n  \n  \n// 限制目标值在上下边界之间 \nfunction clamp(\n  num: number,\n  lowerBound: number,\n  upperBound: number\n): number {\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}\n')),Object(a.b)("h3",null,"resizeHandler"),Object(a.b)("p",null,"resizaHandle其实是起到一个中转站的作用，先从DraggableCore中获取节点和位置信息对象。\n然后根据获取到的对象信息计算出缩放后的宽高，将其作为触发相应的回调的参数。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"})," resizeHandler(handlerName: 'onResize' | 'onResizeStart' | 'onResizeStop', axis): Function {\n    return (e, { node, deltaX, deltaY }) => {\n      // Reset data in case it was left over somehow (should not be possible)\n      if (handlerName === 'onResizeStart') this.resetData();\n\n      // Axis restrictions\n      const canDragX = (this.props.axis === 'both' || this.props.axis === 'x') && axis !== 'n' && axis !== 's';\n      const canDragY = (this.props.axis === 'both' || this.props.axis === 'y') && axis !== 'e' && axis !== 'w';\n      // No dragging possible.\n      if (!canDragX && !canDragY) return;\n\n      // Decompose axis for later use\n      const axisV = axis[0];\n      const axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example\n\n      // Track the element being dragged to account for changes in position.\n      // If a handle's position is changed between callbacks, we need to factor this in to the next callback.\n      // Failure to do so will cause the element to \"skip\" when resized upwards or leftwards.\n      const handleRect = node.getBoundingClientRect();\n      if (this.lastHandleRect != null) {\n        // If the handle has repositioned on either axis since last render,\n        // we need to increase our callback values by this much.\n        // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,\n        if (axisH === 'w') {\n          const deltaLeftSinceLast = handleRect.left - this.lastHandleRect.left;\n          deltaX += deltaLeftSinceLast;\n        }\n        if (axisV === 'n') {\n          const deltaTopSinceLast = handleRect.top - this.lastHandleRect.top;\n          deltaY += deltaTopSinceLast;\n        }\n      }\n      // Storage of last rect so we know how much it has really moved.\n      this.lastHandleRect = handleRect;\n\n      // Reverse delta if using top or left drag handles.\n      if (axisH === 'w') deltaX = -deltaX;\n      if (axisV === 'n') deltaY = -deltaY;\n\n      // 计算缩放后的宽和高\n      let width = this.props.width + (canDragX ? deltaX / this.props.transformScale : 0);\n      let height = this.props.height + (canDragY ? deltaY / this.props.transformScale : 0);\n\n      // Run user-provided constraints.\n      [width, height] = this.runConstraints(width, height);\n\n      const dimensionsChanged = width !== this.props.width || height !== this.props.height;\n\n      // Call user-supplied callback if present.\n      const cb = typeof this.props[handlerName] === 'function' ? this.props[handlerName] : null;\n      // Don't call 'onResize' if dimensions haven't changed.\n      const shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;\n      if (cb && !shouldSkipCb) {\n        e.persist?.();\n        cb(e, { node, size: { width, height }, handle: axis });\n      }\n\n      // Reset internal data\n      if (handlerName === 'onResizeStop') this.resetData();\n    };\n  }\n")),Object(a.b)("h2",null,"再会"),Object(a.b)("p",null,"情如风雪无常,"),Object(a.b)("p",null,"却是一动即殇。"),Object(a.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(a.b)("p",null,"我是冷月心,下期再见。"))}r.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-react-grid-layout-index-mdx-e1919903265833b1b2db.js.map