(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{vUB0:function(t,n,e){"use strict";e.r(n),e.d(n,"_frontmatter",(function(){return r})),e.d(n,"default",(function(){return c}));e("rGqo"),e("yt8O"),e("Btvt"),e("RW0V"),e("91GP"),e("q1tI");var a=e("7ljp"),o=e("Hv6d");var r={},s={_frontmatter:r},l=o.a;function c(t){var n=t.components,e=function(t,n){if(null==t)return{};var e,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)e=r[a],n.indexOf(e)>=0||(o[e]=t[e]);return o}(t,["components"]);return Object(a.b)(l,Object.assign({},s,e,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"前言"),Object(a.b)("p",null,"不管对于前端还是后端,路由都极为重要。虽都叫路由,但二者概念和功能并不相同。\n前端路由指的是当用户访问路径与路由配置路径匹配时,渲染对应的组件;\n后端路由指的是当用户访问路径与路由配置路径匹配时,执行某段业务逻辑(通常是数据接口)。"),Object(a.b)("p",null,"我们开发常用的其实是react-router-dom，但它依赖了react-router。而react-router可谓是面试高频。\n当然，最主要的还是hash路由和browser路由模型的应用和原理。\n此外,Route,Link,AuthRouter,NavLink,Redirect,Switch,WithRouter，Prompt也是常考点。"),Object(a.b)("p",null,"本篇为源码系列核心实现第五篇,对应下图react-router部分。"),Object(a.b)("p",null,Object(a.b)("img",Object.assign({parentName:"p"},{src:"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png",alt:"src"}))),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",Object.assign({parentName:"tr"},{align:null})),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null})))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"name"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"desc")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"hashRouter"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"基于hashChange实现的路由")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"browserRouter"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"基于history核心api实现的路由")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Route"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"用于路径匹配和routeProps传递")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Link"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"点击可跳转到指定路径的链接")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"NavLink"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"在Link基础上，命中路由添加active类名")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"AuthRouter"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"权限路由")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Redirect"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"重定向路由")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Switch"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"单一匹配")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"WithRouter"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"高阶组件，可使被包裹组件获得routeProps")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Prompt"),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"阻止跳转(非预期行为)")))),Object(a.b)("p",null,"温馨提示：为便于演示，贴出的代码会做些简化，建议结合文末源码自行编写测试用例感受下。"),Object(a.b)("h2",null,"宏观认知"),Object(a.b)("h3",null,"基本原理"),Object(a.b)("p",null,"在关注某个功能点实现前，先来一个宏观认知或许会更容易理解。\n不论是hashRouter还是browserRouter，它们其实都只干了一件事:根据用户的不同访问路径，切换不同组件显示。"),Object(a.b)("p",null,"确切的说，这两个东西都算是容器。\n它们用来获取location,history等有意义的对象，并传递给子组件Route。\n路径匹配，组件渲染什么的，其实都是在Route里实现的。"),Object(a.b)("p",null,"这里会涉及一个十分重要的点，如何监听路由变化？"),Object(a.b)("p",null,"并不玄奥，hash路由通过监听window的hashchange事件实现，\nbrowser路由使用原生history 的pushstate和onpopstate实现。"),Object(a.b)("p",null,"无独有偶，vue-router和react-router在实现上大同小异，在browser路由上二者都有用到history api。\n不同的是react-router是用了一个单独的第三方包，就叫history。vue-router则是自己新建了一个history文件夹，\n自己搞了一套，但底层实现上都差不多。"),Object(a.b)("h3",null,"路由初体验"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"hash")),Object(a.b)("p",null,"当点击不同链接的时候，hash值会发生改变，这种改变会被hashchange事件监听到。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-html"}),"    <div>\n        <a href='#/a'>a页面</a>\n        <a href='#/b'>b页面</a>\n    </div>\n    <script>\n        window.addEventListener('hashchange',()=>{\n           console.log( window.location.hash)\n        })\n    <\/script>\n</body>\n\n\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"browser")),Object(a.b)("p",null,"以下是一个mdn的例子，感觉还挺经典的。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nwindow.onpopstate = function(event) {\n  alert("location: " + document.location + ", state: " + JSON.stringify(event.state));\n};\n //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\nhistory.pushState({page: 1}, "title 1", "?page=1");\n //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2  \nhistory.pushState({page: 2}, "title 2", "?page=2");\n//修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3   \nhistory.replaceState({page: 3}, "title 3", "?page=3"); \nhistory.back(); // 弹出 "location: http://example.com/example.html?page=1, state: {"page":1}"\nhistory.back(); // 弹出 "location: http://example.com/example.html, state: null\nhistory.go(2);  // 弹出 "location: http://example.com/example.html?page=3, state: {"page":3}\n\n')),Object(a.b)("p",null,"window.onpopstate是popstate事件在window对象上的事件处理程序。\n每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发。"),Object(a.b)("p",null,"值得注意的是，调用history.pushState()或者history.replaceState()不会触发popstate事件。\n该事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮。\n又或者，js中调用history.back、history.forward、history.go方法。\n此外,a 标签的锚点也会触发该事件."),Object(a.b)("h2",null,"hashRouter实现"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nclass HashRouter extends React.Component {\n  LocationState;\n  state = {\n    location: {\n      pathname: window.location.hash.slice(1),\n    },\n  };\n\n  componentDidMount() {\n    window.addEventListener("hashchange", (e) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: window.location.hash.slice(1) || "/",\n          state: this.LocationState,\n        },\n      });\n    });\n\n    window.location.hash = window.location.hash || "/";\n  }\n\n  render() {\n    let that = this;\n\n    let contextVal= {\n      location: this.state.location,\n      history: {\n        push(to) {\n          if (typeof to === "object") {\n            window.location.hash = to.pathname;\n            that.LocationState = to.state;\n          } else {\n            window.location.hash = to;\n            that.LocationState = null;\n          }\n        },\n      },\n    };\n\n    return (\n      <RouterContext.Provider value={contextVal}>\n        {this.props.children}\n      </RouterContext.Provider>\n    );\n  }\n}\n\n\n\n')),Object(a.b)("p",null,"从上面的代码可以看出，hasnRouter做了三件事。"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"通过context将location,history传递给了子组件(其实就是Route)。"),Object(a.b)("li",{parentName:"ol"},"通过hashchange监听路由变换,更新state。"),Object(a.b)("li",{parentName:"ol"},"根据Link标签传递的to属性类型做不同处理。(本质是调用push方法来改变hash值)")),Object(a.b)("h2",null,"BrowserRouter实现"),Object(a.b)("h3",null,"重写history.pushstate"),Object(a.b)("p",null,"重写是为了在浏览器地址变更的时候,更新对应的视图。\n还有就是，改变一下函数接收的参数,title基本上没什么用。"),Object(a.b)("p",null,"如果你用的官方脚手架，下面这个代码可放在index.html中。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n    !(function (history) {\n      var pushState = history.pushState\n      history.pushState = function (state, title, pathname) {\n        if (typeof window.onpushstate === 'function') {\n          window.onpushstate(state, pathname)\n        } \n        //走旧的是为了更新url 执行新的是为了更新ui\n         pushState.apply(history, arguments)\n      }\n\n    }(window.history))\n\n\n")),Object(a.b)("h3",null,"BrowserRouter"),Object(a.b)("p",null,"在继续深入前，先了解下BrowserRouter的触发链路。"),Object(a.b)("p",null,"点击某个链接(Link),调用push方法将访问路径传递过去。\nBrowserRouter内部会通过pushState函数更新浏览器地址和react内部状态。\n接着，这个变更后的状态会通过context传递到子组件中(Route)。"),Object(a.b)("p",null,"至于之后路径匹配，组件渲染什么的，都是Route的事。\nBrowserRouter只是容器，和HashRouter一样，把该传递的传递了就行。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),' class BrowserRouter extends React.Component{\n  LocationState;\n  state = {\n    location: {\n      pathname: "/",\n    },\n  };\n\n  componentDidMount() {\n    //触发popstate的时候 会执行此函数\n    window.onpopstate = (e) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: document.location.pathname,\n          state: e.state,\n        },\n      });\n    };\n\n    //触发pushstate的时候 会执行此函数\n    //这里结合重写后的history.pushstate会更好理解\n    window.onpushstate = (state,pathname) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: pathname,\n          state: state,\n        },\n      });\n    };\n    \n  }\n\n  render() {\n    let contextVal = {\n      location: this.state.location,\n      history: {\n        push(to) {\n          if (typeof to === "object") {\n            window.history.pushState(to.state, "", to.pathname);\n          } else {\n            window.history.pushState(null, "", to);\n          }\n        },\n      },\n    };\n\n    return (\n      <RouterContext.Provider value={contextVal}>\n        {this.props.children}\n      </RouterContext.Provider>\n    );\n  }\n}\n\n\n\n')),Object(a.b)("h2",null,"Route源码"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"路径匹配和组件渲染")),Object(a.b)("p",null,"Route是一个十分核心的组件，主要用于路径匹配和组件渲染。"),Object(a.b)("p",null,"它从容器组件传递下来的location对象中获取用户访问路径pathname，\n又从props中接收外部传递的path属性和component属性。\n通过pathname和path的一致性进行比对，并决定是否渲染component。\n这是最常用的匹配。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"})," class extends React.Component {\n  static contextType = RouterContext;\n\n  render() {\n    let { path, component: RouteComponent, exact } = this.props;\n\n    let pathname = this.context.location.pathname;\n    let routeProps = {\n      location: this.context.location,\n      history: this.context.history,\n    };\n\n    if (exact) {\n      return pathname === path ? <RouteComponent {...routeProps} /> : null;\n    } else {\n      return pathname.startsWith(path) ? (\n        <RouteComponent {...routeProps} />\n      ) : null;\n    }\n  }\n}\n\n\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Route渲染的三种方式")),Object(a.b)("p",null,"除了component外，还有两种不太常用但也很好用的渲染组件方式:childre和render。\n至于其内部如何实现，以及动态路由参数的实现，在文末源码会有体现，这里就不再贴代码了。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n<Switch>\n    <Route exact path="/"> <Home /></Route>\n    <Route path="/about" component={About} />\n    <Route path="/dashboard" children={<Dashboard />} />\n    <Route path="/news" render={()=><News />} />\n    <Route path="/games" component={()=><Games/>} />\n</Switch>\n\n')),Object(a.b)("p",null,"接下来就是一些小东西了，基本上看代码就能懂大概思路。"),Object(a.b)("h2",null,"Link"),Object(a.b)("p",null,"Link 本质是a标签,只不过跳转方式变成了点击执行push方法,其本质是改变hash。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n class Link extends React.Component {\n  static contextType = RouterContext;\n\n  render() {\n    return (\n      <a\n        href={\n          "#" +\n          (typeof this.props.to === "object"\n            ? this.props.to.pathname\n            : this.props.to)\n        }\n        onClick={() => {\n          this.context.history.push(this.props.to);\n        }}\n      >\n        {this.props.children}\n      </a>\n    );\n  }\n}\n\n\n')),Object(a.b)("h2",null,"NavLink"),Object(a.b)("p",null,"NavLink 本质上是对Link的一个加强,在匹配上对应的路由后添加一个active类名，可使用css自定义样式。\n其他方面，使用方式和传参都和Link一样。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n//判断地址栏路径和to里的路径是否一致,一致则添加active类名\nlet NavLink = (props: Props) => {\n  let { to, exact, children } = props;\n\n  return (\n    <Route\n      path={to}\n      exact={exact}\n      children={(childrenProps) => {\n        return (\n          <Link\n            className={childrenProps.match ? "active" : ""}\n            to={to}\n            {...childrenProps}\n          >\n            {children}\n          </Link>\n        );\n      }}\n    />\n  );\n};\n\n\n')),Object(a.b)("h2",null,"Switch"),Object(a.b)("p",null,"Switch 包裹的组件只会匹配第一个,不会重复匹配"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n class Switch extends React.Component {\n  static contextType = RouterContext;\n\n\n  render() {\n    //从context获取的路径与子组件进行匹配\n    let pathname = this.context.location.pathname;\n    if (!this.props.children) return null;\n\n    let children;\n\n    children = Array.isArray(this.props.children)\n      ? this.props.children\n      : [this.props.children];\n\n    //此处不用forEach是因为它无法中途return\n    for (let i = 0; i < children.length; i++) {\n      let child = children[i];\n      const { path = "/", exact = false } = child.props;\n      let paramsName = [];\n      let regexp = pathToRegexp(path, paramsName, { end: exact });\n      let res = pathname.match(regexp);\n      //一旦匹配到后续就不再匹配\n      if (res) return child;\n    }\n\n    return null;\n  }\n}\n\n\n')),Object(a.b)("h2",null,"Redirect"),Object(a.b)("p",null,"如果所有路径都没匹配,会跳转到Redirect to 指定的页面。\n这个一般放在Switch内部最后位置，用于兜底。\n此外，Redirect也可以结合权限路由使。比如登录验证，不符合预期就重定向到登录页。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"})," class Redirect extends React.Component {\n  static contextType = RouterContext;\n  render() {\n    this.context.history.push(this.props.to);\n    return null;\n  }\n}\n\n\n")),Object(a.b)("h2",null,"权限路由"),Object(a.b)("p",null,"渲染对应路径的组件前先判断是否有权限，有则渲染,否则重定向到指定页面。"),Object(a.b)("p",null,"权限路由=Route+自定义逻辑。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n  let Protected = (props: Props) => {\n  let { path, component: RouteComponent } = props;\n\n  return (\n    <Route\n      path={path}\n      render={(renderProp) => {\n        if (window.localStorage.getItem("auth") === "success") {\n          return <RouteComponent {...props} {...renderProps} />;\n        } else {\n          return <Redirect to="/" />;\n        }\n      }}\n    />\n  );\n};\n\n')),Object(a.b)("h2",null,"withRouter"),Object(a.b)("p",null,"withRouter相比其他几个可能不太常用，但某些特定场景需要用到它。\n事实上，只有被容器包裹的Route才能从容器身上拿到上下文对象,从而获取history,location,match等属性。\n对于非路由渲染的组件(如APP组件)要想拿到这些属性，需要使用withRouter。"),Object(a.b)("p",null,"但仅仅如此也是不够的，真正数据来源还是在容器。只有容器才会通过context传递history,location,match等属性。\nwithRouter作为一个高阶组件,它会将上下文传递的属性交给被包裹的组件(App)。\n所以withRouter包裹的组件,必须放在路由容器里才会生效。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"容器包裹")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"import {BrowserRouter} from 'react-router-dom'\nimport App from './App'\nconst el=<BrowserRouter><App/></BrowserRouter>\nrender(el,document.getElementById('root'))\n\n\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"WithRouter实现")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\n\nimport React, { ComponentType } from "react";\nimport { Route, RouteComponentProps } from "./";\n\nlet WithRouter = (Component) => {\n  //外层参数 如<App xxx={xxx}/>\n  return (props: any) => {\n    // 内层路由参数透传\n    return (\n      <Route\n        render={(routeProps: RouteComponentProps) => (\n          <Component {...routeProps} {...props} />\n        )}\n      />\n    );\n  };\n};\n\nexport default WithRouter;\n\n\n\n')),Object(a.b)("h2",null,"阻止跳转"),Object(a.b)("p",null,"阻止跳转的目的是对用户的误操作造成的非预期行为进行提示。\n比如填写了一半的表单,用户不小心点了其他链接,再回来表单被清空了，这就很难受。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"class Prompt extends React.Component{\n  static contextType = RouterContext;\n  render() {\n    const { when, message } = this.props;\n    if (when) {\n      this.context.history.block(message);\n    } else {\n      this.context.history.block(null);\n    }\n    return null;\n  }\n}\n\n\n")),Object(a.b)("p",null,"其处理逻辑是对标志信息的收集,在点击Link时候，push方法执行,根据标志位进行弹窗提示。\n如果用户取消,则不跳转,反之,跳转。确切的说，这部分逻辑是放在了push方法中。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'//容器组件中\nlet contextVal= {\n  location: this.state.location,\n  history: {\n    push(to) {\n      if (this.message) {\n        let flag = window.confirm(\n          this.message(typeof to === "object" ? to.pathname : to)\n        );\n\n        if (!flag) return;\n      }\n      if (typeof to === "object") {\n        window.history.pushState(to.state, "", to.pathname);\n      } else {\n        window.history.pushState(null, "", to);\n      }\n    },\n    block(message) {\n      this.message = message;\n    },\n  },\n};\n\n\n')),Object(a.b)("p",null,"为了便于理解，最后补一个小测试案例。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nfunction A(props) {\n  const [jump, setJump] = useState(false);\n  const [val, setVal] = useState("");\n\n//如果输入框的值无效 就直接跳\n// 如果值有效  弹框提示\n  useEffect(() => {\n    if (val.length === 0) {\n      setJump(false);\n    } else {\n      setJump(true);\n    }\n  }, [val]);\n\n  return (\n    <div>\n      <Prompt\n        when={jump}\n        message={(location: string) => `Do you want to go ${location}?`}\n      />\n      <form>\n        <input value={val} onChange={(e) => setVal(e.target.value)} />\n        <input type="submit" value="按我" />\n      </form>\n    </div>\n  );\n}\n\n\n')),Object(a.b)("h2",null,"相关链接"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate"}),"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate"))),Object(a.b)("h2",null,"源码压缩包"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/lengyuexin/code"}),"https://github.com/lengyuexin/code"))),Object(a.b)("h2",null,"再会"),Object(a.b)("p",null,"情如风雪无常,"),Object(a.b)("p",null,"却是一动既殇。"),Object(a.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(a.b)("p",null,"我是冷月心,下期再见。"))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-react-router-dom-index-mdx-4f2b8f843fe363d1a0f6.js.map