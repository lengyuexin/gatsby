(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{umgy:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return a})),n.d(t,"default",(function(){return s}));n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("91GP"),n("q1tI");var o=n("7ljp"),r=n("Hv6d");var a={},l={_frontmatter:a},c=r.a;function s(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(o.b)(c,Object.assign({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",null,"前言"),Object(o.b)("p",null,"装饰器可对指定的类/类方法/属性/参数进行装饰,扩展其功能。"),Object(o.b)("p",null,"它本质是一个函数,底层实现上依赖Object.defineProperty。"),Object(o.b)("p",null,"逐步发展至今,装饰器不再只是简化代码的语法糖,还可作为某些特定场景的解决方案(比如鉴权)。"),Object(o.b)("p",null,"保持装饰器的单一职责,通过灵活组合,可以让代码更为简洁明了,让开发更为高效。"),Object(o.b)("p",null,"下面以一个ts项目为例,介绍下常用类型装饰器的基本使用和业务场景。"),Object(o.b)("h2",null,"项目初始化"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"全局安装ts ",Object(o.b)("inlineCode",{parentName:"li"},"npm install -g typescript")),Object(o.b)("li",{parentName:"ol"},"新建文件夹并进入"),Object(o.b)("li",{parentName:"ol"},"生成package.json ",Object(o.b)("inlineCode",{parentName:"li"},"npm init -y")),Object(o.b)("li",{parentName:"ol"},"生成tsconfig.json ",Object(o.b)("inlineCode",{parentName:"li"},"tsc --init")),Object(o.b)("li",{parentName:"ol"},"项目中安装ts和ts-node ",Object(o.b)("inlineCode",{parentName:"li"},"npm i typescript ts-node ")),Object(o.b)("li",{parentName:"ol"},"项目中安装nodemon ",Object(o.b)("inlineCode",{parentName:"li"},"npm i nodemon")),Object(o.b)("li",{parentName:"ol"},"tsconfig中设置experimentalDecorators为true,添加装饰器支持"),Object(o.b)("li",{parentName:"ol"},"package.json中添加运行脚本 start:",Object(o.b)("inlineCode",{parentName:"li"},"nodemon  -e  ts  --exec ts-node  src/app")),Object(o.b)("li",{parentName:"ol"},"启动项目 ",Object(o.b)("inlineCode",{parentName:"li"},"npm start"))),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"ts-node将ts编译成js文件并执行"),Object(o.b)("li",{parentName:"ul"},"nodemon检测到目标文件发生更改后自动重启"),Object(o.b)("li",{parentName:"ul"},"nodemon -e 表示添加支持的文件扩展, --exec表示执行指定命令"),Object(o.b)("li",{parentName:"ul"},"如果觉得隐式any 很不爽,可以在tsconfig中设置noImplicitAny为false")),Object(o.b)("h2",null,"基本使用"),Object(o.b)("h3",null,"类装饰器"),Object(o.b)("p",null,"类装饰器作用在指定类上,target拿到的就是类的构造函数。"),Object(o.b)("p",null,"拿到target后可以做很多事,比如增加额外的方法和属性。"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\nconst logName: ClassDecorator = target => {\n  // 反射api,形如target[prop]\n  // 下文还会用到反射\n  // npm上的 reflect-metadata也可以看看\n  const name = Reflect.get(target, 'name');\n  console.log(name);\n};\n\n@logName \nclass User {}\n\n\n")),Object(o.b)("h3",null,"类方法装饰器"),Object(o.b)("p",null,"类方法装饰器作用在类的方法上,有三个参数,分别是类的构造函数(静态方法)或者原型对象(实例方法),属性名和该属性的描述对象。"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"const check: MethodDecorator = (target, key, descriptor: PropertyDescriptor) => {\n // 缓存旧函数,实际上就是装饰器作用的目标对象\n // 这里指的是say方法\n const fn = descriptor.value;\n // 重写该方法,自定义一些逻辑\n // 装饰要保留原有功能,所以最后要调用之前的旧方法\n  descriptor.value = function () {\n    if (target.constructor.name !== 'User') {\n      console.error('method say must called by class User');\n      return;\n    }\n    fn.call(this);\n  };\n // 返回属性描述对象\n  return descriptor;\n};\n\n\nclass User {\n  @check // 使用类方法装饰器\n  say() {\n    console.log('hi~');\n  }\n}\n\nclass Cat {\n  @check // 使用类方法装饰器\n  say() {\n    console.log('hi~');\n  }\n}\n\nnew User().say();// hi~\nnew Cat().say();// method say must called by class User\n\n")),Object(o.b)("p",null,"上述使用的装饰器都是不接收参数的。如果需要接收参数,就再包装一层函数(利用了闭包)。"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\n// auth是一个简单的权限装饰器,限定某方法只有管理员可执行\nconst auth =\n  (isAdmin = false) =>\n    (target, key, descriptor: PropertyDescriptor) => {\n      const fn = descriptor.value;\n      descriptor.value = function () {\n        if (!isAdmin) {\n          console.error('no auth');\n          return;\n        }\n        fn.call(this);\n      };\n\n      return descriptor;\n    };\n\nclass User {\n  @auth(true) // auth方法调用,返回一个类方法装饰器\n  edit() {\n    console.log('edit');\n  }\n}\n\n// auth入参为真值,打印 edit\n// 反之,打印 no auth\nnew User().edit();\n\n")),Object(o.b)("p",null,"多个装饰器可以作用同一个目标对象."),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\nclass UserCtrl {\n\n  @auth(['admin'])// 鉴权\n  @get('/api/user/list') // 设置请求方法\n  listUser(){\n    // xxx\n  }\n \n}\n")),Object(o.b)("h2",null,"业务场景"),Object(o.b)("p",null,"一个比较经典的场景是借助反射和装饰器实现server端路由的自动装载。"),Object(o.b)("p",null,"下面以一个koa项目为例,介绍下这部分功能的具体实现。"),Object(o.b)("h3",null,"koa环境搭建"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"安装koa和koa-router ",Object(o.b)("inlineCode",{parentName:"li"},"npm i koa koa-router")),Object(o.b)("li",{parentName:"ol"},"安装koa相关类型声明 ",Object(o.b)("inlineCode",{parentName:"li"},"npm i @types/koa @types/koa-router")),Object(o.b)("li",{parentName:"ol"},"根目录src/app.js写入如下代码")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\nimport Koa from 'koa';\nimport Router from 'koa-router';\n\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(3000, () => {\n  console.log('run server...');\n});\n\n")),Object(o.b)("ol",{start:5},Object(o.b)("li",{parentName:"ol"},"启动项目 ",Object(o.b)("inlineCode",{parentName:"li"},"npm start")),Object(o.b)("li",{parentName:"ol"},"可以浏览器打开 ",Object(o.b)("a",Object.assign({parentName:"li"},{href:"http://localhost:3000"}),"http://localhost:3000")," 端口测试一下")),Object(o.b)("h3",null,"预期效果"),Object(o.b)("p",null,"上边的代码还没有做有优化,业务逻辑都耦合在一起。"),Object(o.b)("p",null,"我们需要一个更为清晰,更可维护的代码组织方式。"),Object(o.b)("p",null,"向下面这样:"),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"\n@controller('/main')\nexport default class MainCtrl {\n  @get('/index')\n  async index(ctx) {\n    ctx.body = 'hello world';\n  }\n  @get('/home')\n  async home(ctx) {\n    ctx.body = 'hello home';\n  }\n}\n\n// 我们希望上述代码等价于如下写法\n\nrouter.get('/main/index',ctx=>{\n   ctx.body = 'hello world';\n})\nrouter.get('/main/home',ctx=>{\n   ctx.body = 'hello home';\n})\n")),Object(o.b)("h3",null,"实现思路"),Object(o.b)("p",null,"我们的最终目标是拼出controller中包含的路由信息并完成注册,这其实是一个数据set和get的过程。"),Object(o.b)("p",null,"通过装饰器在相应controller的原型对象上设置请求前缀和路由信息。"),Object(o.b)("p",null,"然后遍历所有controller并实例化,借助反射获取到原型上存储的数据,完成路由注册。"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"装饰器decorator.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"export const controller =\n  (prefix = ''): ClassDecorator =>\n    (target: any) => {\n      target.prototype.prefix = prefix;\n    };\n\ntype Method = 'get' | 'post' | 'delete' | 'options' | 'put' | 'head';\n\nexport interface RouteDefinition {\n  path: string;\n  requestMethod: Method;\n  methodName: string;\n}\n\nconst creatorFactory =\n  (requestMethod: Method) =>\n    (path: string): MethodDecorator =>\n      (target, name) => {\n        if (!Reflect.has(target.constructor, 'routes')) {\n          Reflect.defineProperty(target.constructor, 'routes', {\n            value: [],\n          });\n        }\n        const routes = Reflect.get(target.constructor, 'routes');\n        routes.push({\n          requestMethod,\n          path,\n          methodName: name,\n        });\n      };\n\nexport const get = creatorFactory('get');\n// export const post = creatorFactory('post');\n// export const del = creatorFactory('delete');\n// export const put = creatorFactory('put');\n// export const options = creatorFactory('options');\n// export const head = creatorFactory('head');\n\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"注册路由app.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import Koa from 'koa';\nimport Router from 'koa-router';\nimport MainCtrl from './main-ctrl';\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\n\n[MainCtrl].forEach(controller => {\n  const instance: any = new controller();\n  const { prefix } = instance;\n  const routes = Reflect.get(controller, 'routes');\n  routes.forEach(route => {\n    router[route.requestMethod](prefix + route.path, ctx => {\n      instance[route.methodName](ctx);\n    });\n  });\n});\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(3000, () => {\n  console.log('run server...');\n});\n\n\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"控制器main-ctrl.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import { controller, get } from './decorator';\n@controller('/main')\nexport default class MainCtrl {\n  @get('/index')\n  async index(ctx) {\n    ctx.body = 'hello world';\n  }\n  @get('/home')\n  async home(ctx) {\n    ctx.body = 'hello home';\n  }\n}\n\n")),Object(o.b)("h3",null,"自动扫描"),Object(o.b)("p",null,"上述实现还存在一个弊端,如果控制器特别多,每次都需要手动导入,很麻烦。"),Object(o.b)("p",null,"一种更优雅的方式是批量扫描,使用glob扫描指定的控制器目录(比如controllers)。"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"安装glob ",Object(o.b)("inlineCode",{parentName:"li"},"npm i glob")),Object(o.b)("li",{parentName:"ol"},"根目录新建load.ts,写入如下代码")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import * as glob from 'glob';\nimport path from 'path';\nexport default (folder: string, router: any) => {\n  // 扫描指定文件夹下所有ts文件\n  glob.sync(path.join(folder, '**/*.ts')).forEach(item => {\n    // 加载controller\n    const controller = require(item).default;\n    // 实例化\n    const instance: any = new controller();\n    const { prefix } = instance;\n    const routes = Reflect.get(controller, 'routes');\n    routes.forEach(route => {\n      router[route.requestMethod](prefix + route.path, ctx => {\n        instance[route.methodName](ctx);\n      });\n    });\n  });\n};\n")),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},"修改app.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import Koa from 'koa';\nimport Router from 'koa-router';\nimport path from 'path';\nimport load from './load';\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\nload(path.resolve(__dirname, './controllers'), router);\napp.use(router.routes());\napp.use(router.allowedMethods());\napp.listen(3000, () => {\n  console.log('run server...');\n});\n")),Object(o.b)("ol",{start:4},Object(o.b)("li",{parentName:"ol"},"将之前的main-ctrl.ts移动到新建的controllers目录中"),Object(o.b)("li",{parentName:"ol"},"浏览器访问对应路径,测试")),Object(o.b)("h2",null,"源码地址"),Object(o.b)("p",null,Object(o.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/lengyuexin/code/blob/main/ts-server.zip"}),"decorator")),Object(o.b)("h2",null,"再会"),Object(o.b)("p",null,"情如风雪无常,"),Object(o.b)("p",null,"却是一动即殇。"),Object(o.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(o.b)("p",null,"我是冷月心,下期再见。"))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-decorator-index-mdx-2500d02cfaa08f6239a2.js.map