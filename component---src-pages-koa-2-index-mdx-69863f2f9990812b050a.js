(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{"/gVu":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n("shca"),r=(n("xwgP"),n("N0F1")),s=n("Hv6d"),c={},l={_frontmatter:c},o=s.a;function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)(o,Object.assign({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",null,"前言"),Object(r.b)("p",null,"koa和express都是nodejs的web框架,但它们的设定不同。\nexpress自身集成很多东西,比较重,适合企业级的应用开发。\nkoa功能纯粹,扩展功能需高度依赖生态。这种可插拔的形式使得其更为灵活,轻量。\n从npm周下载量来看,express千万级,koa十万级,差距还是很明显。\n本篇为源码系列核心实现第一篇,对应下图koa2部分。"),Object(r.b)("p",null,Object(r.b)("img",Object.assign({parentName:"p"},{src:"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png",alt:"src"}))),Object(r.b)("h2",null,"核心功能概览"),Object(r.b)("p",null,"koa2即使是全部代码,也没多少东西。从整体上看,主要分为五大方向。"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null})),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null})))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"name"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"desc")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"application"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"创建上下文,合并中间件,启动服务")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"request"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"对原生http模块req的扩展")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"response"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"对原生http模块res的扩展")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"context"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"对request和response的合并与代理")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"compose"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"合并中间件(洋葱模型的体现)")))),Object(r.b)("h2",null,"koa是如何启动一个服务的？"),Object(r.b)("h3",null,"基本使用"),Object(r.b)("p",null,"在详解上述功能模块前,先来看看koa最基础的使用。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const Koa=require('koa')\nconst app=new Koa()\napp.listen(3000,()=>{\n    console.log('run server__')\n})\n\n")),Object(r.b)("h3",null,"核心实现"),Object(r.b)("p",null,"简单的几行代码就实现了koa最核心的功能——提供基础的HTTP应用服务。\n它是如何实现的呢？其实也没什么玄机,直接用了内置的http模块。\n注意一个小细节:Application是一个类,这也就解释了在使用koa时为什么要new一下。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const http=require('http')\nclass Application{\n    listen(...args){\n       const server= http.createServer()\n       server.listen(...args)\n    }\n}\n")),Object(r.b)("h2",null,"koa是如何处理一个请求的？"),Object(r.b)("h3",null,"基础使用"),Object(r.b)("p",null,"既然应用启动是直接使用了http模块,那对于请求处理是不是也和http模块的处理相似呢？\n是的,确实如此,但koa做的更多。先来看一个例子,\n下面代码背后包含了koa对于一个请求到响应的完整处理过程。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"app.use(async ctx=>{\n    ctx.body='hello world'\n})\n\n")),Object(r.b)("h3",null,"一个请求--响应带来的思考"),Object(r.b)("p",null,"就这？一个use,一个ctx,一个body,啥也没看出来啊？\n还有,为啥要加个async ,去掉不行？"),Object(r.b)("p",null,"从视觉入手，这几个最直观的点也最好解释。\n带着问题去思考问题，是我最喜欢的学习方式。\nok,接下来，我们就看一下koa内部是如何处理请求的。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"class Application{\n    use(fn){\n        this.fn=fn\n    }\n    handleRequest(req,res){\n        const ctx=this.createContext(req,res)\n        this.fn(ctx)\n    }\n     listen(...args){\n       const server= http.createServer(this.handleRequest.bind(this))\n       server.listen(...args)\n    }\n}\n\n")),Object(r.b)("p",null,"这几行代码没什么玄机，所谓的use方法,不过是将接收的函数暂存，后续在handleRequest中执行。"),Object(r.b)("p",null,"handleRequest函数见名知意，用于处理请求。其实，也就是把原生http模块\ncreateServer的事件处理函数做了一个提取，并将上下文this指向我们自己\n写的Application类。其中，this.fn(ctx)这行代码，解释了为什么每一个请求处理函数都会接收ctx参数。"),Object(r.b)("h3",null,"createContext是什么？"),Object(r.b)("p",null,"看名字是要创建上下文。是的，这就是koa独特的地方。"),Object(r.b)("p",null,"koa将原生http模块事件处理函数的req和res参数合二为一后又做了一层增强。\n最终的结果就是:req,res有的,ctx皆有。req,res没有的,ctx还有。\n对开发者而言，合二为一后完全无需关心某个方法是req的还是res的，直接一个ctx完事。"),Object(r.b)("p",null,"说了这么多，我们就来看一下createContext的庐山真面目。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"class Application{\n    constructor(){\n        //这三个是外部引入的\n        this.context=context;\n        this.request=request;\n        this.response=response;\n    }\n    createContext(req,res){\n        //使用Object.create是为了在不对原模块进行干扰的情况下进行扩展,也是一层继承\n        const context=Object.create(this.context)\n        const request=Object.create(this.request)\n        const response=Object.create(this.response)\n        //上下文关联与合并\n        context.req=context.request.req=req    \n        context.res=context.response.res=res\n        //返回一个合并后的context;\n        return context\n    }\n}\n\n")),Object(r.b)("p",null,"为了便于理解，我在必要部分加了一些注释。\n暂且不管构造器里的context，request，response是什么，先只看createContext函数做了什么。\n里边有两行看起来很绕的连续赋值代码，其实就是往ctx上挂载东西。"),Object(r.b)("p",null,"比如你用原生http模块结束响应是res.end(),那现在可以用ctx.res.end()，也可以用ctx.response.res.end()。\nreq和res是一样的道理，这里就不再赘述了。"),Object(r.b)("h3",null,"request和response"),Object(r.b)("p",null,"到这里，我们之前疑惑的use,ctx已经解释完。在进一步解释async和body前，我们暂且引出一个新的问题。\nrequest和response与http模块事件处理函数的req,res的关系是什么？"),Object(r.b)("p",null,"首先可以肯定的是，绝不是同一个东西。但是，request和response是对req和res的一个增强。\n这两个文件，是koa单独搞出来的，其内部使用了getter,setter。"),Object(r.b)("p",null,"先来看一个request的简单示例："),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const request={\n    get url() {\n        return this.req.url;\n    }\n}\nmodule.exports=request\n")),Object(r.b)("p",null,"这里的this指向request对象，但仅这样还看不出玄机，别忘了在createContext方法中的request身上恰好挂了一个req。\n这意味着什么？意味着访问ctx.request.req 就是访问原生req。"),Object(r.b)("p",null,"举个例子：上边request中的url访问方式看似是ctx.request.url，实际上是ctx.request.req.url。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"app.use(ctx => {\n    ctx.body=ctx.request.req.url===ctx.request.url //true\n})\n\n")),Object(r.b)("p",null,"也许你会觉得，这个例子看起来好像是代理啊，如何起到增强作用呢?"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const request = {\n    get headers() {\n        return this.req.headers;\n    },\n    get header() {\n        return this.req.headers;\n    },\n}\n\n")),Object(r.b)("p",null,"个人习惯问题，在写代码时会纠结是headers还是header。\nkoa考虑的很人性化，不管你用哪种，都对，最终都是访问的headers。\n从这点考虑，岂不就是容错性的增强？当然，实际的增强并不仅限于此，甚至可以自定义你想要的业务逻辑。"),Object(r.b)("p",null,"response和request同理，这里不再赘述。只提最关键的一点，body。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const response = {\n    _body: '',\n    get body() {\n        return this._body\n    },\n    set body(newBody) {\n        this._body = newBody\n    }\n}\nmodule.exports = response\n")),Object(r.b)("p",null,"这样一看是不是body也没那么神奇了呢？不过就是一个变量而已。\n若是访问，直接返回变量_body;若是设置，接收新值完成更新。"),Object(r.b)("p",null,"也许你会好奇，ctx.body和这个body是一个东西吗？是的，当然是。\n那它们是如何关联上的？看起来是代理？是的，就是代理，通过context。"),Object(r.b)("h3",null,"神奇的context代理"),Object(r.b)("p",null,"先来看看context内部实现吧。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const context = {}\n\nfunction delegateGet(prop, key) {\n    //__defineGetter__这个方法是当访问对象的某个key时,执行回调\n    context.__defineGetter__(key, function () {\n        return this[prop][key]\n    })\n}\nfunction delegateSet(prop, key) {\n    context.__defineSetter__(key, function (newValue) {\n        this[prop][key] = newValue\n    })\n}\n\ndelegateGet('response', 'body')//访问ctx.body\ndelegateSet('response', 'body')//设置ctx.body='xxx'\ndelegateGet('request', 'url')//ctx.url<=>ctx.request.url\n\nmodule.exports = context\n\n")),Object(r.b)("p",null,"看完上述代码来个小总结吧。\nctx本质是代理,并非增强;\nctx做的响应相关的,一定是交给response;\nctx做的请求相关的,一定是交给request。"),Object(r.b)("p",null,"关于",Object(r.b)("strong",{parentName:"p"},"defineGetter"),",可参考文末MDN相关链接。如果你去看koa源码,你会发现它使用了一个第三方包:delegates,其实这东西实现也是用的",Object(r.b)("strong",{parentName:"p"},"defineGetter")),Object(r.b)("h3",null,"神奇的组合能力:compose"),Object(r.b)("p",null,"到这里我们之前提到的疑惑只剩下async尚未解决，接下来就深入展开一波。\n在探究compose函数实现前，先来想一下为什么需要组合？解决了什么问题？"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\napp.use(bodyParser())\napp.use(koaStatic())\n...\n\n")),Object(r.b)("p",null,"koa中，use函数可以多次调用,但是默认情况下只会执行第一个。\n后边的如果想执行,需要上游调用next函数,也就是use函数的第二个参数。\n那如何涉及异步怎么搞？这就是async的意义所在。\n多个中间件如何执行呢？这就是compose函数的意义。(洋葱模型)"),Object(r.b)("img",{src:"https://img-blog.csdnimg.cn/20201126182252279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODEzNDkx,size_16,color_FFFFFF,t_70#pic_center",alt:"onion",style:{zoom:"30%"}}),Object(r.b)("img",{src:"https://img-blog.csdnimg.cn/20201126182252258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODEzNDkx,size_16,color_FFFFFF,t_70#pic_center",alt:"compose",style:{zoom:"30%"}}),Object(r.b)("p",null,"依次输出123456"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\napp.use((ctx, next) => {\n    console.log(1)\n    next()\n    console.log(6)\n})\napp.use((ctx, next) => {\n    console.log(2)\n    next()\n    console.log(5)\n})\napp.use((ctx, next) => {\n    console.log(3)\n    next()\n    console.log(4)\n})\n\n")),Object(r.b)("p",null,"接下来我们来研究一波它的实现。\n核心三要素，按存储顺序依次执行，支持异步，洋葱模型。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n//做一个小小的改造，支持多个use调用\n    use(fn){\n        this.middlewares.push(fn)\n    }\n\n  compose(ctx) {\n    //这里dispatch(也就是next)使用箭头函数\n    //内部的this就指向了自定义的Application\n    const dispatch = (index) => {\n        //越界处理 handleRequest还有then 不能直接return ,要返回promise\n        if (index === this.middlewares.length) return Promise.resolve()\n        //获取当前的中间件 最开始是第一个\n        const middleware = this.middlewares[index]\n        // 中间件执行需要两个参数\n        const exec = middleware(ctx, () => dispatch(++index))\n        //有可能这个方法没有加async,包装一层\n        //保证返回的是一个promise\n        //这样handleRequest的then函数就不会报错(下文解释)\n        return Promise.resolve(exec)\n    }\n    return dispatch(0)\n}\n\n")),Object(r.b)("p",null,"到这里，compose实现基本就完活了，边界细节可以去看koa-compose。"),Object(r.b)("p",null,"上边有提到最后要返回promise，看起来有些突兀。莫慌，补上最后一波代码就可以理解了。"),Object(r.b)("h3",null,"handleRequest"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"\n  handleRequest(req, res) {\n\n        const ctx = this.createContext(req, res)\n      //组合中间件 并执行返回后的promise,获取到_body 响应出去\n      //注意看这里，是有一个then的\n      //这就意味着最后不管你写的函数加不加async，进了compose，都是异步\n        this.compose(ctx).then(() => {\n             //默认只能处理buffer 和string\n            let _body = ctx.body;\n            if (_body === '') {\n                //如果没设置body 就给个默认值,状态码设置为404\n                res.statusCode = 404\n                _body = 'not found'\n                return res.end(_body)\n            } else if (_body instanceof Stream) {\n                //koa也支持直接返回一个文件流,通过pipe就可以做到 \n                return _body.pipe(res)\n            } else if (typeof _body !== 'null' && typeof _body === 'object') {\n                //对对象的处理\n                return res.end(JSON.stringify(_body))\n            } else if (_body == null) {\n                //null 和undefined 无法直接调用toString 可以拼接一下\n                return res.end(_body + '')\n            } else {\n                //其他类型的直接toString \n                return res.end(_body.toString())\n            }\n        }).catch(err => {\n            //这里为app添加了错误监听\n            //application继承events模块即可\n            this.emit('error', err)\n         })\n    }\n\n")),Object(r.b)("p",null,"到这里核心部分就都解释完了，源码我会以压缩包形式给出。"),Object(r.b)("p",null,"最后来一波加餐，中间件的实现,本质就是函数返回一个接收ctx,next为参数的异步函数。"),Object(r.b)("h2",null,"koa-static"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function koaStatic(dirname) {\n    return async function (ctx, next) {\n        try {\n            let filepath = path.join(dirname, ctx.path)\n            const stat = fs.statSync(filepath);\n            if (stat.isDirectory()) {\n                filepath = path.join(filepath, './index.html')\n                if (fs.existsSync(filepath)) {\n                    ctx.set('Content-Type', `text/html;charset=utf-8`)\n                    ctx.body = fs.createReadStream(filepath)\n                } else {\n                    await next()\n                }\n            } else {\n                if (fs.existsSync(filePath)) {\n                    //来自第三方包mime\n                    const mimeType = mime.getType(filepath)\n                    ctx.set('Content-Type', `${mimeType};charset=utf-8`)\n                    ctx.body = fs.createReadStream(filepath)\n                } else {\n                    await next()\n                }\n            }\n\n        } catch (error) {\n            await next()\n        }\n    }\n}\n\n//根据目录查找对应文件 找到返回 找不到next\napp.use(koaStatic(__dirname))\napp.use(koaStatic(path.resolve(__dirname, 'public')))\n\n")),Object(r.b)("h2",null,"相关链接"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"defineGetter"),": ",Object(r.b)("a",Object.assign({parentName:"p"},{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter"}),"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter"),"__"),Object(r.b)("h2",null,"源码压缩包"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/lengyuexin/code"}),"https://github.com/lengyuexin/code"))),Object(r.b)("h2",null,"再会"),Object(r.b)("p",null,"情如风雪无常，"),Object(r.b)("p",null,"却是一动既殇。"),Object(r.b)("p",null,"感谢你这么好看还来阅读我的文章，"),Object(r.b)("p",null,"我是冷月心，下期再见。"))}b.isMDXComponent=!0},BiVN:function(e,t,n){},EsZP:function(e,t,n){},Hv6d:function(e,t,n){"use strict";var a=n("KPh1"),r=n("qRUh"),s=n("xwgP"),c=n.n(s),l=n("Wbzz"),o=n("d33t"),b=n.n(o),i=(n("vPK/"),n("Zttt")),p=n("EYWl"),u=n("JLKy"),d=n("k7Sn"),j=function(e){return d.supportedLanguages[e].replace(/ /g," ")},m=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){var e=this.props,t=e.translations,n=e.lang,a=e.languageLink,r=e.editUrl;return c.a.createElement("div",{className:"translations"},c.a.createElement(u.a,{style:{fontFamily:'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",\n    "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans",\n    "Droid Sans", "Helvetica Neue", sans-serif'}},t.length>0&&c.a.createElement(c.a.Fragment,null,c.a.createElement("span",null,"Translated by readers into: "),t.map((function(e,r){return c.a.createElement(c.a.Fragment,{key:e},e===n?c.a.createElement("b",null,j(e)):c.a.createElement(l.Link,{to:a(e)},j(e)),r===t.length-1?"":" • ")}))),"zh-hans"!==n&&c.a.createElement(c.a.Fragment,null,c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement(l.Link,{to:a("zh-hans")},"Read the original")," • ",c.a.createElement("a",{href:r,target:"_blank",rel:"noopener noreferrer"},"Improve this translation")," • ",c.a.createElement(l.Link,{to:"/"+n},"View all translated posts")," ")))},t}(c.a.Component),O=n("L6NH"),g=n("p3AD");function h(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function f(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?h(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):h(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var x=function(e){function t(){return e.apply(this,arguments)||this}return Object(r.a)(t,e),t.prototype.render=function(){console.log(this.props);var e=this.props,t=e.pageContext,a=e.children,r=e.location,s=e.previous,o=e.next,u=e.translations,d=b()(this.props,"queryData.site.siteMetadata.title"),h=t.langKey,x=t.slug;u&&(u=u.slice()).sort((function(e,t){return j(e)<j(t)?-1:1})),function(e){switch(e){case"ru":case"bg":n("EsZP"),n("s85H");break;case"uk":n("EsZP"),n("s85H"),n("Mq6Z"),n("e/YJ");break;case"cs":case"da":case"de":case"es":case"fi":case"fr":case"he":case"hu":case"it":case"nl":case"no":case"pl":case"pt-br":case"sk":case"sr":case"sq":case"sv":case"tr":n("Mq6Z"),n("e/YJ");break;case"vi":n("Vjog"),n("Pf5Y");break;case"fa":n("BiVN");break;case"ar":n("xpFW")}}(h);var y=function(e,t){var n=e.replace(t+"/","");return function(e){return"zh-hans"===e?n:""+e+n}}(x,h),N=y("en"),q="https://github.com/gaearon/overreacted.io/edit/master/src/pages/"+N.slice(1,N.length-1)+"/index"+("zh-hans"===h?"":"."+h)+".md";return c.a.createElement(i.a,{location:r,title:d},c.a.createElement(p.a,{lang:h,title:t.frontmatter.title,description:t.frontmatter.spoiler,slug:x,date:t.frontmatter.date}),c.a.createElement("div",{style:{marginLeft:"auto",marginRight:"auto",maxWidth:Object(g.a)(24)}},c.a.createElement("article",null,c.a.createElement("header",null,c.a.createElement("h1",{style:{color:"var(--textTitle)"}},t.frontmatter.title),c.a.createElement("p",{style:f(f({},Object(g.b)(-.2)),{},{display:"block",marginBottom:Object(g.a)(1),marginTop:Object(g.a)(-.8)})},Object(O.a)(t.frontmatter.date,h)),u&&u.length>0&&c.a.createElement(m,{translations:u,editUrl:q,languageLink:y,lang:h})),c.a.createElement("div",null,a)),c.a.createElement("aside",null,c.a.createElement("nav",null,c.a.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},c.a.createElement("li",null,s&&c.a.createElement(l.Link,{to:s.fields.slug,rel:"prev",style:{marginRight:20}},"← ",s.frontmatter.title)),c.a.createElement("li",null,o&&c.a.createElement(l.Link,{to:o.fields.slug,rel:"next"},o.frontmatter.title," →")))))))},t}(c.a.Component);t.a=function(e){return c.a.createElement(l.StaticQuery,{query:"2199005656",render:function(t){return c.a.createElement(x,Object.assign({queryData:t},e))}})}},Mq6Z:function(e,t,n){},Pf5Y:function(e,t,n){},Vjog:function(e,t,n){},"e/YJ":function(e,t,n){},k7Sn:function(e,t){t.supportedLanguages={en:"English","zh-hans":"简体中文"}},s85H:function(e,t,n){},shca:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}n.d(t,"a",(function(){return a}))},"vPK/":function(e,t,n){},xpFW:function(e,t,n){}}]);
//# sourceMappingURL=component---src-pages-koa-2-index-mdx-69863f2f9990812b050a.js.map