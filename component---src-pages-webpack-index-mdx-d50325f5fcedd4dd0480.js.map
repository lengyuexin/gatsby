{"version":3,"sources":["webpack:///./src/pages/webpack/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,4BACA,wHAGA,sDACA,qBAAG,iCAAKC,WAAW,KAAQ,CACvB,IAAO,sFACP,IAAO,UAEX,8BACA,4BACA,mJAEkB,sBAAQA,WAAW,KAAnB,mBAFlB,0FAIA,4BACA,wDACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,6nCAoDL,6DACA,8BACA,4BACA,oHAGA,+CACA,gHAEA,kCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,g7BA0CL,uJAIA,iCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,+kHAqJL,sDACA,gCACA,kCACA,qHAEA,8FAEA,sCACA,8GAEA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,6JAQL,kFAEA,gCACA,kCACA,wGAEA,sCACA,oGAEA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,unBAwBL,+BACA,sBACE,kBAAIA,WAAW,MAAK,+BAAGA,WAAW,MAAS,CACvC,KAAQ,uCADQ,wCAItB,4BACA,gCACA,gCACA,yCACA,qCAKJJ,EAAWK,gBAAiB","file":"component---src-pages-webpack-index-mdx-d50325f5fcedd4dd0480.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`前言`}</h2>\n    <p>{`站在面试角度，webpack核心功能实现无非是plugin，loader。\n更深入一点，自然是同步加载和异步加载。\n如果说到加分项,那优化配置，提高打包速度也都算，但这部分不再本系列中。`}</p>\n    <p>{`本篇为源码系列核心实现第六篇,对应下图webpack部分。`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png\",\n        \"alt\": \"src\"\n      }}></img></p>\n    <h2>{`同步加载`}</h2>\n    <h3>{`概述`}</h3>\n    <p>{`不论是同步加载还是异步加载，webpack打包结果都是一个IIFE。\n该IIFE接收一个类型为对象的modules参数， 该参数是一个以模块路径为key,函数为value的对象,其中函数体是文件内容。\n对于每个require语法，都会被替换为`}<strong parentName=\"p\">{`webpack_require`}</strong>{`，每个文件路径都会补全为src下相关路径。\nmodule(打包前),chunk(打包过程中),bundle(打包后) 是同一套代码在webpack打包不同时机的不同称呼。`}</p>\n    <h3>{`实现`}</h3>\n    <p>{`直接丢代码了，关键位置已经加了注释，代码不多，应该比较好理解。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`(function (modules) {\n\n    //模块缓存\n    var installedModules = {}\n\n    //自己实现的__webpack_require__ 取代原生的require\n    function __webpack_require__(moduleId) {\n\n        //命中缓存 直接返回\n        if (installedModules[moduleId]) {\n            return installedModules[moduleId].exports\n        }\n        //未命中缓存 添加\n        var module = installedModules[moduleId] = {\n            id: moduleId,//模块id\n            load: false,//默认模块没有被加载,\n            exports: {},//导出的内容\n        }\n\n        //加载对应模块\n        //这里的this指向为module.exports貌似是一种规范\n        modules[moduleId].call(\n          module.exports, module, \n          module.exports, __webpack_require__\n          );\n\n        module.load = true//已经加载\n\n        return module.exports\n\n    }\n\n    //加载入口模块\n    return __webpack_require__('./src/index.js')\n\n})(\n\n    {\n        './src/index.js': (function (module, exports, __webpack_require__) {\n            const title = __webpack_require__('./src/title.js')\n            console.log(title)\n        }),\n        './src/title.js': (function (module, exports,) {\n            module.exports = 'hello'\n        })\n\n\n    })\n\n`}</code></pre>\n    <p>{`注意：同步加载用了闭包做缓存，在面试时候这是一个很好的闭包使用场景举例。`}</p>\n    <h2>{`异步加载`}</h2>\n    <h3>{`概述`}</h3>\n    <p>{`首先要明确一点，异步加载包含同步加载。\n最先被加载的入口文件index.js就是同步加载，异步加载指的是其他模块。\n整个异步加载过程其实有三个重要环节:同步加载，e函数，t函数。`}</p>\n    <p>{`同步加载好理解，e函数和t函数是什么东西呢？`}</p>\n    <p>{`e函数内部会通过创建script并指定src去加载其他模块，最后会把加载的依赖结果处理成promise返回。\nt函数内部会进行esmodule和commonjs的兼容处理。`}</p>\n    <h3>{`打包前vs打包后`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n//打包前\nlet btn = document.createElement('button')\nbtn.innerText = '按我'\ndocument.body.appendChild(btn)\n\nbtn.addEventListener('click', () => {\n    import(/* webpackChunkName:'title' */'./title').then(res => {\n        console.log(res.default)\n    })\n})\n\n\n//打包后\n\n(function (modules) {\n//...    \n}, {\n    \"./src/index.js\":\n\n        (function (module, exports, __webpack_require__) {\n\n            let btn = document.createElement('button');\n            btn.innerText = '按我';\n            document.body.appendChild(btn);\n            btn.addEventListener('click', () => {\n                __webpack_require__.e(/*! import() | title */ \"title\")\n                    .then(__webpack_require__.t.bind(null, \n                    /*! ./title */ \"./src/title.js\", 7))\n                    .then(res => {\n                        console.log(res.default);\n                    });\n            });\n\n        })\n})\n\n\n\n`}</code></pre>\n    <p>{`e函数之所以能够.then，是因为已经成了promise。\n根据promise的链式调用原理,e函数return的结果会交给t函数继续处理。\n同理，t函数的处理结果也会再次向后传递。\n而此时的结果必然是兼容处理后的，带有default属性的对象。`}</p>\n    <h3>{`异步加载的实现`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n\n  // The module cache\n  var installedModules = {};\n\n  // object to store loaded and loading chunks\n  // undefined = chunk not loaded, null = chunk preloaded/prefetched\n  // Promise = chunk loading, 0 = chunk loaded\n  var installedChunks = {\n    \"main\": 0\n  };\n\n\n  function __webpack_require__(moduleId) {\n\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module, module.exports,\n      __webpack_require__\n     );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n\n\n  __webpack_require__.e = function (chunkId) {\n\n    var promises = []\n\n    var installedChunkData = installedChunks[chunkId]\n\n     //同样的资源加载后不会加载第二次\n    if (installedChunkData !== 0) {\n      var promise = new Promise(function (resolve, reject) {\n        installedChunkData = installedChunks[chunkId] = [resolve, reject]\n      })\n\n      promises.push(installedChunkData[2] = promise);\n\n      var script = document.createElement('script')\n      script.src = chunkId + '.bundle.js'\n      document.head.appendChild(script)\n    }\n\n\n    return Promise.all(promises)\n\n\n  }\n\n\n  var jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n\n  //核心是push方法\n  jsonpArray.push = webpackJsonpCallback;\n\n\n  // 异步加载的模块结构如下\n\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"say\"], {\n\n  \"./src/say.js\":\n    (function (module, exports) {\n      module.exports = 'say import ';\n    })\n\n}]);\n\n//该模块被加载就会执行push方法，也就是执行webpackJsonpCallback\n\n// webpackJsonpCallback 接收一个data参数\n// data形如 [[chunkId1,chunkId2],{}]\n  function webpackJsonpCallback(data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n\n    var moduleId, chunkId, i resolves = [];\n    for ( var = 0; i < chunkIds.length; i++) {\n         chunkId = chunkIds[i];\n         //存储resolves回调数组\n        resolves.push(installedChunks[chunkId][0]);//[resolve,reject,promise]\n      }\n        //将所有加载后的chunkId标识为已加载\n      installedChunks[chunkId] = 0;\n    }\n\n  //将异步加载的模块与原模块合并，后续会在t函数内部执行一次webpack_require加载\n    for (moduleId in moreModules) {\n        modules[moduleId] = moreModules[moduleId];\n    }\n\n   //取出resolves回调数组并逐步执行\n    while (resolves.length) {\n      resolves.shift()();\n    }\n\n\n//t函数会加载异步合并的代码并进行esmodule和commonjs语法的兼容处理\n//经过t函数处理后的结果必然是一个带有default属性的对象\n//promsie中，返回的内容会在下一个then中获取\n\n// 默认进入时mode是7\n // create a fake namespace object\n  // mode & 1: value is a module id, require it\n  // mode & 2: merge all properties of value into the ns\n  // mode & 4: return value when already ns object\n  // mode & 8|1: behave like require\n  __webpack_require__.t = function (value, mode) {\n\n    if (mode & 1) value = __webpack_require__(value);\n    if (mode & 8) return value;\n    if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n    if (mode & 2 && typeof value != 'string'){\n      for (var key in value){\n         __webpack_require__.d(ns, key,\n          function (key) { return value[key]; }.bind(null, key)\n          );\n      }\n      \n    } \n    return ns;\n  };\n\n\n  };\n\n\n`}</code></pre>\n    <p>{`关键部分已经给出注释，但可能细节上还需要动手多测试，验证。`}</p>\n    <h2>{`loader`}</h2>\n    <h3>{`loader概述`}</h3>\n    <p>{`webpack本身只能处理js文件，loader就是扩展webpack打包能力用的，\n告诉它非js格式文件该怎么处理。比如css相关的style-loader,css-loader。`}</p>\n    <p>{`loader其实和node中的pipe很像，如同流水线，一个loader之后可以接另一个loader。\n但最终，必须是一个js形式收尾。`}</p>\n    <h3>{`实现一个简易loader`}</h3>\n    <p>{`loader的本质是一个函数，该函数通过source参数接收输入，通过返回值输出。\n下面以一个markdown-loader为例，举例说明一个loader是如何实现的。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const marked = require('marked')\nmodule.exports = source => {\n  const html = marked(source)\n  return  \\`module.exports = \\${JSON.stringify(html)}\\`\n}\n`}</code></pre>\n    <p>{`这就完事了？是的，就是如此简单。\n测试的话，这个loader可以在webpack的配置文件中以本地路径形式加载。`}</p>\n    <h2>{`plugin`}</h2>\n    <h3>{`plugin概述`}</h3>\n    <p>{`Webpack 的插件本质就是各种钩子，这就像组件生命周期一样，不同阶段存在不同钩子函数。\nwebpack赋予了这些钩子函数特定的能力，直接拿过来用就行了。`}</p>\n    <h3>{`实现一个简易plugin`}</h3>\n    <p>{`plugin可以写成一个类的形式，然后身上有个apply方法，这个是webpack约定好的。\n下面写一个简单的小插件，用于打印构建过程涉及的文件名。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`class GetFileListPlugin {\n    apply(compiler) {\n        compiler.hooks.emit.tap('GetFileListPlugin ', compilation => {\n            // compilation => 可以理解为此次打包的上下文\n            for (const name in compilation.assets) {\n                console.log(name)\n                const contents = compilation.assets[name].source()\n                compilation.assets[name] = {\n                    //用于返回新内容 \n                    source: () => contents,\n                    //返回内容大小\n                    size: () => noComments.length\n                }\n            }\n        })\n\n    }\n}\n\nmodule.exports = GetFileListPlugin\n\n`}</code></pre>\n    <h2>{`源码压缩包`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/lengyuexin/code\"\n        }}>{`https://github.com/lengyuexin/code`}</a></li>\n    </ul>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动既殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}