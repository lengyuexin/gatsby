(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{"3QS5":function(e,n,b){"use strict";b.r(n),b.d(n,"_frontmatter",(function(){return c})),b.d(n,"default",(function(){return s}));b("rGqo"),b("yt8O"),b("Btvt"),b("RW0V"),b("91GP"),b("q1tI");var t=b("7ljp"),l=b("Hv6d");var c={},a={_frontmatter:c},u=l.a;function s(e){var n=e.components,b=function(e,n){if(null==e)return{};var b,t,l={},c=Object.keys(e);for(t=0;t<c.length;t++)b=c[t],n.indexOf(b)>=0||(l[b]=e[b]);return l}(e,["components"]);return Object(t.b)(u,Object.assign({},a,b,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,"前言"),Object(t.b)("p",null," 随着业务的不断迭代，项目代码会变得越来越多。"),Object(t.b)("p",null," 如果前期不注意开发规范和代码层次结构规划，到后期项目中就会出现大量的冗余代码，维护困难。"),Object(t.b)("p",null," 到最后，多是以重构，新建项目重写收尾。"),Object(t.b)("p",null,"原本，可以更好的。"),Object(t.b)("p",null,"本周双休，今天我们就来聊一下如何减少项目中的冗余代码。"),Object(t.b)("h2",null,"为什么会出现冗余代码"),Object(t.b)("p",null,"结合我的经验来看，出现冗余代码的情况包括但不限于以下几个方面："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"对于公共请求/业务逻辑未做提取"),Object(t.b)("li",{parentName:"ul"},"能收敛为聚合函数的函数直接提供给外部调用"),Object(t.b)("li",{parentName:"ul"},"能合并的函数未合并"),Object(t.b)("li",{parentName:"ul"},"相似结构的复制粘贴")),Object(t.b)("h2",null,"如何解决"),Object(t.b)("p",null,"核心思想是能合并的合并，能提取的提取。"),Object(t.b)("p",null,"其实都是建议，这种东西，咬牙也能坚持。"),Object(t.b)("p",null,"能过就过，不能过还能离咋的？"),Object(t.b)("h3",null,"提取公共请求/业务逻辑"),Object(t.b)("p",null,"比如对某项数据进行订阅和取消订阅，二者只是动作上的区别，参数是一致的。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"不要在每个模块下都写一份订阅和取消订阅的逻辑，提取到全局公共逻辑中")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"不要写两个处理函数，用动作区分即可（以mobx为例）"))),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"// subscribes 为用户订阅数据id集合\n\n// bad case\nif(subscribes.includes(row.id)){\n    store.cancel()\n}else{\n    store.add()\n}\n\n\n// good case\n\nstore.subscribe(row.id,subscribes.includes(row.id))\n\nasync function subscribe(id,flag){\n    let url=''\n    if(flag){\n        // 取消订阅\n        url='/api/subscribe/cancel'\n    }else{\n        //新增订阅\n        url='/api/subscribe/add'\n    }\n    await axios.post(url,{id})\n}\n\n")),Object(t.b)("p",null,"此外，还有一个更典型的场景。登录平台获取用户信息后，为方便其他模块使用，这个信息应该放在全局，而不是每次使用再去发一个请求。"),Object(t.b)("h3",null,"聚合函数的收敛"),Object(t.b)("p",null,"给定这样一个场景，新建项目并指定负责人后，会同步资源(该项目)到权限系统，并为资源对应的人赋权。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"// bad case \n// 创建或者更新资源信息\nexport function addOrUpdate(){}\n//赋权\nexport function addPermission(){}\n")),Object(t.b)("p",null,"上述这种写法存在一个弊端，直接提供给外部的话，两个方法都要调用。"),Object(t.b)("p",null,"事实上，这两个是一体的行为，创建或者更新资源后，紧接着就是赋权。addPermission是addOrUpdate的子函数，直接内部调用就好。这样外部只需要调用聚合后的函数addOrUpdate即可。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"// good case \n// 创建或者更新资源信息\nexport function addOrUpdate(){\n    addPermission();\n}\n//赋权\nfunction addPermission(){}\n")),Object(t.b)("h3",null,"能合并的函数进行合并"),Object(t.b)("p",null,"这个比较好理解，就像上边提到的订阅和取消订阅，只是动作差异，完全可以合并为一个。"),Object(t.b)("p",null,"此外，类似的还有插入数据和更新数据，这里动作判断标准是是否有id,有的就是更新，没有就是插入。"),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"if(params.id){\n    service.update(params)\n}else{\n    service.add(params)\n}\n")),Object(t.b)("h3",null,"善用配置表思维"),Object(t.b)("p",null,"之所以选择复制粘贴，是因为相似结构很多，对于这种情况，",Object(t.b)("a",Object.assign({parentName:"p"},{href:"https://juejin.cn/post/6960562154839900190"}),"配置表"),"+循环则是更优解。"),Object(t.b)("h2",null,"再会"),Object(t.b)("p",null,"情如风雪无常,"),Object(t.b)("p",null,"却是一动即殇。"),Object(t.b)("p",null,"感谢你这么好看还来阅读我的文章,"),Object(t.b)("p",null,"我是冷月心,下期再见。"))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-remove-useless-code-index-mdx-59294eb4799726c2045d.js.map