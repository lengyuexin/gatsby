{"version":3,"sources":["webpack:///./src/pages/online-fatal/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"gRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,4BACA,uDACA,gEACA,0DACA,qBAAG,iCAAKC,WAAW,KAAQ,CACvB,IAAO,kHACP,IAAO,SAEX,4BACA,0DAAyC,sBAAQA,WAAW,KAAnB,QAAzC,IAAsF,sBAAQA,WAAW,KAAnB,YAAtF,WACA,sCAAqB,+BAAGA,WAAW,KAAQ,CACvC,KAAQ,iDADS,WAGrB,qBAAG,iCAAKA,WAAW,KAAQ,CACvB,IAAO,sHACP,IAAO,gBAEX,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wNAaL,uDACA,uBAAK,kCAAMA,WAAW,OAAU,IAA3B,wGAIL,iDACA,wCAAuB,sBAAQA,WAAW,KAAnB,OAAvB,KACA,kDACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,2TAkBL,gCACA,2DACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,0YAmBL,2CAA0B,sBAAQA,WAAW,KAAnB,OAA1B,gBACA,8BACA,mDACA,sCACA,sBACE,kBAAIA,WAAW,MAAf,iBACA,kBAAIA,WAAW,MAAf,4BACA,kBAAIA,WAAW,MAAf,kCAEF,2EACA,4BACA,gCACA,gCACA,yCACA,qCAKJJ,EAAWK,gBAAiB","file":"component---src-pages-online-fatal-index-mdx-79597f87ad525670e9de.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`背景`}</h2>\n    <p>{`近期开发的模块上线后，测试过程中发现了一个bad case。`}</p>\n    <p>{`前端调用了一个查询服务接口，然后整个服务cpu 立即飙升到100%，甚至以上。`}</p>\n    <p>{`这直接导致线上服务处于瘫痪状态，一群oncall就干过来了，好慌。`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3144d6c798f14e0c85c7b4cd3fcc1a6e~tplv-k3u1fbpfcp-zoom-1.image\",\n        \"alt\": null\n      }}></img></p>\n    <h2>{`成因`}</h2>\n    <p>{`根本原因是调用了lodash的uniqWith和isEqual方法对`}<strong parentName=\"p\">{`大数据量`}</strong>{`且`}<strong parentName=\"p\">{`重复率不高的数据`}</strong>{`进行深度去重。`}</p>\n    <p>{`github上也有一个相关的`}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/lodash/lodash/issues/5254\"\n      }}>{`issue.`}</a></p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/defd2c10c1b84546ab159ae1c3e5e6c6~tplv-k3u1fbpfcp-watermark.image?\",\n        \"alt\": \"image.png\"\n      }}></img></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import {uniqWith, isEqual} from 'lodash'\n// example\nconst objects = [ \n{ x: 1, y: 2 }, \n{ x: 2, y: 1 },\n{ x: 1, y: 2 },\n]; \n\nuniqWith(objects, isEqual); \n// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n`}</code></pre>\n    <p>{`在 uniqWith 中，调用了isEqual进行两两比较。`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`isEqual(objects[0], objects[1])\nisEqual(objects[0], objects[2])\nisEqual(objects[1], objects[2])\n`}</code></pre>\n    <p>{`线上数据高达5w,但并不足以说明是数量级导致的。`}</p>\n    <p>{`还有一个重要因素会增加比对耗时，`}<strong parentName=\"p\">{`重复率`}</strong>{`。`}</p>\n    <p>{`如果重复率极低，几万的数量，还不足以让cpu占满。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{` function test(){\n   const obj = {\n      x: 1,\n      y: 2,\n    };\n    const arr = [];\n    for (let i = 0; i < 50000; i++) {\n      arr.push(obj);\n    }\n    return lodash.uniqWith(arr, lodash.isEqual);\n  }\n    console.time('重复率测试');\n    test();\n    console.timeEnd('重复率测试');\n    // 重复率测试: 4.779ms\n`}</code></pre>\n    <h2>{`复现demo`}</h2>\n    <p>{`为了更直观的感受这个过程，我写了如下示例代码。仅有几行，但足以复现。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const { uniqWith, isEqual } = require('lodash');\nconst http = require('http');\nhttp\n  .createServer(async (req, res) => {\n    const arr = [];\n    for (let i = 0; i < 10000; i++) {\n      arr.push({\n        n: Math.random() * 20000,\n        m: Math.random() * 20000,\n      });\n    }\n    console.log(uniqWith(arr, isEqual));\n    res.end('hello world');\n  })\n  .listen(3000);\n\n`}</code></pre>\n    <p>{`node执行完上述代码后，可在终端使用`}<strong parentName=\"p\">{`top`}</strong>{`命令观察cpu占用情况。`}</p>\n    <h2>{`解决方案`}</h2>\n    <p>{`最直接的方案是放弃uniqWith和isEqual。`}</p>\n    <p>{`需要进一步思考的点有三个：`}</p>\n    <ul>\n      <li parentName=\"ul\">{`如此庞大的数据量是否合理？`}</li>\n      <li parentName=\"ul\">{`既然重复率如此低，近乎没有重复，是否有去重必要？`}</li>\n      <li parentName=\"ul\">{`能否从数据源头上控制不出现重复数据？哪怕重复的只有一两条。`}</li>\n    </ul>\n    <p>{`结合我经历的这个场景，排查完业务逻辑后发现真实数据量不会这么大，重复的数据很少，且可以从源头上控制。`}</p>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动即殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}