{"version":3,"sources":["webpack:///./src/pages/xss-csrf/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","style","background","isMDXComponent"],"mappings":"4RAOO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,6BACA,4BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,8JAKA,4BACA,8BACE,iBAAGC,WAAW,cAAd,gCAEF,YAAC,IAAD,CAAGD,QAAQ,KACT,iJACoC,uBADpC,+CAEsC,uBAFtC,kEAKF,4BACA,YAAC,IAAD,CAAGA,QAAQ,KAAX,eACQ,uBADR,yCAEkC,uBAFlC,4BAGqB,wBAErB,gCACA,4BACA,YAAC,IAAD,CAAGE,MAAO,CACRC,WAAY,aACXH,QAAQ,KAFX,yIAMA,4BACA,qBAAG,sBAAQC,WAAW,KAAnB,oDACH,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXH,QAAQ,KAFX,kCAG2B,uBAH3B,mCAI4B,uBAJ5B,6DAOA,qBAAG,sBAAQC,WAAW,KAAnB,eACH,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXH,QAAQ,KAFX,mCAG4B,uBAH5B,sCAI+B,wBAE/B,qBAAG,sBAAQC,WAAW,KAAnB,kBACH,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXH,QAAQ,KAFX,uCAGgC,uBAHhC,2CAIoC,uBAJpC,qDAWJH,EAAWO,gBAAiB","file":"component---src-pages-xss-csrf-index-mdx-9da66da5ba282eb2ec7a.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nimport P from '../../components/Panel.js';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h2>{`XSS`}</h2>\n    <h3>{`描述`}</h3>\n    <P mdxType=\"P\">\nXSS全称是CrossnSite Scripting(跨站脚本)，为了和CSS区分，故叫它XSS。\nXSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。\n如:窃取Cookie,监听用户行为(如输入账号密码后直接发送到黑客服务器),修改 DOM 伪造登录表单,生成浮窗广告。\n    </P>\n    <h3>{`类型`}</h3>\n    <blockquote>\n      <p parentName=\"blockquote\">{`XSS攻击的实现主要有三种方式:存储型、反射型和文档型`}</p>\n    </blockquote>\n    <P mdxType=\"P\">\n      <p>{`存储型就是将恶意脚本存储到数据库，服务端读取后返回，客户端执行。常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库。\n在页面渲染过程中直接执行, 相当于执行一段未知逻辑的JS代码，安全性得不到保障。`}<br />{`\n反射型XSS指的是恶意脚本作为网络请求的参数，经过服务器，然后再反射到HTML文档中`}<br />{`\n文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档！`}</p>\n    </P>\n    <h3>{`防范`}</h3>\n    <P mdxType=\"P\">\n对用户的输入进行转义  <br /> \nCSP内容安全策略限制其他域下的资源加载,禁止向其它域提交数据,提供上报机制<br />\n利用HttpOnly,使得js无法操控cookie<br />\n    </P>\n    <h2>{`CSRF攻击`}</h2>\n    <h3>{`描述`}</h3>\n    <P style={{\n      background: 'lightblue'\n    }} mdxType=\"P\">\nCSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。\n自动发GET(图片链接)请求获取个人信息,自动post表单提交进行转账汇款以及其他的恶意操作\n    </P>\n    <h3>{`防范`}</h3>\n    <p><strong parentName=\"p\">{`1. 利用Cookie的SameSite属性，可以设置为三个值:Strict、Lax和None`}</strong></p>\n    <P style={{\n      background: '#4AC29A'\n    }} mdxType=\"P\">\n在Strict模式下，浏览器完全禁止第三方请求携带Cookie<br />\n在None模式下，也就是默认模式，请求会自动携带上 Cookie<br />\n在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a标签发送get请求的情况下可以携带Cookie\n    </P>\n    <p><strong parentName=\"p\">{`2.  验证来源站点`}</strong></p>\n    <P style={{\n      background: '#4AC29A'\n    }} mdxType=\"P\">\n这就需要要用到请求头中的两个字段: Origin和Referer<br />\n这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。<br />\n    </P>\n    <p><strong parentName=\"p\">{`3. CSRF Token`}</strong></p>\n    <P style={{\n      background: '#4AC29A'\n    }} mdxType=\"P\">\n浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。<br />\n浏览器发送请求，会带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应<br />\n这个字符串就是CSRF Token，通常第三方站点无法拿到这个 token, 会被服务器给拒绝。\n    </P>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}