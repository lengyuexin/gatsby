(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{reK6:function(t,n,e){"use strict";e.r(n),e.d(n,"_frontmatter",(function(){return u})),e.d(n,"default",(function(){return p}));e("rGqo"),e("yt8O"),e("Btvt"),e("RW0V"),e("91GP"),e("q1tI");var b=e("7ljp"),r=e("Hv6d"),c=e("JLKy");var u={},o={_frontmatter:u},l=r.a;function p(t){var n=t.components,e=function(t,n){if(null==t)return{};var e,b,r={},c=Object.keys(t);for(b=0;b<c.length;b++)e=c[b],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,["components"]);return Object(b.b)(l,Object.assign({},o,e,{components:n,mdxType:"MDXLayout"}),Object(b.b)("h3",null,"解释"),Object(b.b)(c.a,{mdxType:"P"},"死锁是指两个或两个以上的进程在执行过程中,由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。 若无外力作用,它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。"),Object(b.b)("h3",null,"产生条件"),Object(b.b)(c.a,{style:{background:"#4AC29A"},mdxType:"P"},"互斥：在一段时间内某资源只由一个进程占用,必须释放后其他的进程才能使用。",Object(b.b)("br",null),"请求和保持：指进程已经保持至少一个资源,但又提出了新的资源请求, 而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放。",Object(b.b)("br",null),"不剥夺：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放。",Object(b.b)("br",null),"环路等待：指在发生死锁时,必然存在一个进程——资源的环形链p0=>p1=>p2=>p0",Object(b.b)("br",null)),Object(b.b)("h3",null,"预防"),Object(b.b)(c.a,{style:{background:"lightblue"},mdxType:"P"},"破坏产生死锁原因中的任意某个条件,如:有序资源分配法,银行家算法"))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-os-deadlock-index-mdx-c67155900f34839283ff.js.map