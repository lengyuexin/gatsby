{"version":3,"sources":["webpack:///./src/pages/react-router-dom/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-pages-react-router-dom-index-mdx-fd58e10518faf3bfbba5.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`前言`}</h2>\n    <p>{`不管对于前端还是后端,路由都极为重要。虽都叫路由,但二者概念和功能并不相同。\n前端路由指的是当用户访问路径与路由配置路径匹配时,渲染对应的组件;\n后端路由指的是当用户访问路径与路由配置路径匹配时,执行某段业务逻辑(通常是数据接口)。`}</p>\n    <p>{`我们开发常用的其实是react-router-dom，但它依赖了react-router。而react-router可谓是面试高频。\n当然，最主要的还是hash路由和browser路由模型的应用和原理。\n此外,Route,Link,AuthRouter,NavLink,Redirect,Switch,WithRouter，Prompt也是常考点。`}</p>\n    <p>{`本篇为源码系列核心实现第五篇,对应下图react-router部分。`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://lengyuexin.github.io/gatsby/static/src-c54cf51e73a8fdc229c79ea7b981b607.png\",\n        \"alt\": \"src\"\n      }}></img></p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}></th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}></th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`name`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`desc`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`hashRouter`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`基于hashChange实现的路由`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`browserRouter`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`基于history核心api实现的路由`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Route`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`用于路径匹配和routeProps传递`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Link`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`点击可跳转到指定路径的链接`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`NavLink`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`在Link基础上，命中路由添加active类名`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`AuthRouter`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`权限路由`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Redirect`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`重定向路由`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Switch`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`单一匹配`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`WithRouter`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`高阶组件，可使被包裹组件获得routeProps`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Prompt`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`阻止跳转(非预期行为)`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>{`温馨提示：为便于演示，贴出的代码会做些简化，建议结合文末源码自行编写测试用例感受下。`}</p>\n    <h2>{`宏观认知`}</h2>\n    <h3>{`基本原理`}</h3>\n    <p>{`在关注某个功能点实现前，先来一个宏观认知或许会更容易理解。\n不论是hashRouter还是browserRouter，它们其实都只干了一件事:根据用户的不同访问路径，切换不同组件显示。`}</p>\n    <p>{`确切的说，这两个东西都算是容器。\n它们用来获取location,history等有意义的对象，并传递给子组件Route。\n路径匹配，组件渲染什么的，其实都是在Route里实现的。`}</p>\n    <p>{`这里会涉及一个十分重要的点，如何监听路由变化？`}</p>\n    <p>{`并不玄奥，hash路由通过监听window的hashchange事件实现，\nbrowser路由使用原生history 的pushstate和onpopstate实现。`}</p>\n    <p>{`无独有偶，vue-router和react-router在实现上大同小异，在browser路由上二者都有用到history api。\n不同的是react-router是用了一个单独的第三方包，就叫history。vue-router则是自己新建了一个history文件夹，\n自己搞了一套，但底层实现上都差不多。`}</p>\n    <h3>{`路由初体验`}</h3>\n    <p><strong parentName=\"p\">{`hash`}</strong></p>\n    <p>{`当点击不同链接的时候，hash值会发生改变，这种改变会被hashchange事件监听到。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-html\"\n      }}>{`    <div>\n        <a href='#/a'>a页面</a>\n        <a href='#/b'>b页面</a>\n    </div>\n    <script>\n        window.addEventListener('hashchange',()=>{\n           console.log( window.location.hash)\n        })\n    </script>\n</body>\n\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`browser`}</strong></p>\n    <p>{`以下是一个mdn的例子，感觉还挺经典的。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nwindow.onpopstate = function(event) {\n  alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));\n};\n //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\nhistory.pushState({page: 1}, \"title 1\", \"?page=1\");\n //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2  \nhistory.pushState({page: 2}, \"title 2\", \"?page=2\");\n//修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3   \nhistory.replaceState({page: 3}, \"title 3\", \"?page=3\"); \nhistory.back(); // 弹出 \"location: http://example.com/example.html?page=1, state: {\"page\":1}\"\nhistory.back(); // 弹出 \"location: http://example.com/example.html, state: null\nhistory.go(2);  // 弹出 \"location: http://example.com/example.html?page=3, state: {\"page\":3}\n\n`}</code></pre>\n    <p>{`window.onpopstate是popstate事件在window对象上的事件处理程序。\n每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发。`}</p>\n    <p>{`值得注意的是，调用history.pushState()或者history.replaceState()不会触发popstate事件。\n该事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮。\n又或者，js中调用history.back、history.forward、history.go方法。\n此外,a 标签的锚点也会触发该事件.`}</p>\n    <h2>{`hashRouter实现`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nclass HashRouter extends React.Component {\n  LocationState;\n  state = {\n    location: {\n      pathname: window.location.hash.slice(1),\n    },\n  };\n\n  componentDidMount() {\n    window.addEventListener(\"hashchange\", (e) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: window.location.hash.slice(1) || \"/\",\n          state: this.LocationState,\n        },\n      });\n    });\n\n    window.location.hash = window.location.hash || \"/\";\n  }\n\n  render() {\n    let that = this;\n\n    let contextVal= {\n      location: this.state.location,\n      history: {\n        push(to) {\n          if (typeof to === \"object\") {\n            window.location.hash = to.pathname;\n            that.LocationState = to.state;\n          } else {\n            window.location.hash = to;\n            that.LocationState = null;\n          }\n        },\n      },\n    };\n\n    return (\n      <RouterContext.Provider value={contextVal}>\n        {this.props.children}\n      </RouterContext.Provider>\n    );\n  }\n}\n\n\n\n`}</code></pre>\n    <p>{`从上面的代码可以看出，hasnRouter做了三件事。`}</p>\n    <ol>\n      <li parentName=\"ol\">{`通过context将location,history传递给了子组件(其实就是Route)。`}</li>\n      <li parentName=\"ol\">{`通过hashchange监听路由变换,更新state。`}</li>\n      <li parentName=\"ol\">{`根据Link标签传递的to属性类型做不同处理。(本质是调用push方法来改变hash值)`}</li>\n    </ol>\n    <h2>{`BrowserRouter实现`}</h2>\n    <h3>{`重写history.pushstate`}</h3>\n    <p>{`重写是为了在浏览器地址变更的时候,更新对应的视图。\n还有就是，改变一下函数接收的参数,title基本上没什么用。`}</p>\n    <p>{`如果你用的官方脚手架，下面这个代码可放在index.html中。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n    !(function (history) {\n      var pushState = history.pushState\n      history.pushState = function (state, title, pathname) {\n        if (typeof window.onpushstate === 'function') {\n          window.onpushstate(state, pathname)\n        } \n        //走旧的是为了更新url 执行新的是为了更新ui\n         pushState.apply(history, arguments)\n      }\n\n    }(window.history))\n\n\n`}</code></pre>\n    <h3>{`BrowserRouter`}</h3>\n    <p>{`在继续深入前，先了解下BrowserRouter的触发链路。`}</p>\n    <p>{`点击某个链接(Link),调用push方法将访问路径传递过去。\nBrowserRouter内部会通过pushState函数更新浏览器地址和react内部状态。\n接着，这个变更后的状态会通过context传递到子组件中(Route)。`}</p>\n    <p>{`至于之后路径匹配，组件渲染什么的，都是Route的事。\nBrowserRouter只是容器，和HashRouter一样，把该传递的传递了就行。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{` class BrowserRouter extends React.Component{\n  LocationState;\n  state = {\n    location: {\n      pathname: \"/\",\n    },\n  };\n\n  componentDidMount() {\n    //触发popstate的时候 会执行此函数\n    window.onpopstate = (e) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: document.location.pathname,\n          state: e.state,\n        },\n      });\n    };\n\n    //触发pushstate的时候 会执行此函数\n    //这里结合重写后的history.pushstate会更好理解\n    window.onpushstate = (state,pathname) => {\n      this.setState({\n        location: {\n          ...this.state.location,\n          pathname: pathname,\n          state: state,\n        },\n      });\n    };\n    \n  }\n\n  render() {\n    let contextVal = {\n      location: this.state.location,\n      history: {\n        push(to) {\n          if (typeof to === \"object\") {\n            window.history.pushState(to.state, \"\", to.pathname);\n          } else {\n            window.history.pushState(null, \"\", to);\n          }\n        },\n      },\n    };\n\n    return (\n      <RouterContext.Provider value={contextVal}>\n        {this.props.children}\n      </RouterContext.Provider>\n    );\n  }\n}\n\n\n\n`}</code></pre>\n    <h2>{`Route源码`}</h2>\n    <p><strong parentName=\"p\">{`路径匹配和组件渲染`}</strong></p>\n    <p>{`Route是一个十分核心的组件，主要用于路径匹配和组件渲染。`}</p>\n    <p>{`它从容器组件传递下来的location对象中获取用户访问路径pathname，\n又从props中接收外部传递的path属性和component属性。\n通过pathname和path的一致性进行比对，并决定是否渲染component。\n这是最常用的匹配。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{` class extends React.Component {\n  static contextType = RouterContext;\n\n  render() {\n    let { path, component: RouteComponent, exact } = this.props;\n\n    let pathname = this.context.location.pathname;\n    let routeProps = {\n      location: this.context.location,\n      history: this.context.history,\n    };\n\n    if (exact) {\n      return pathname === path ? <RouteComponent {...routeProps} /> : null;\n    } else {\n      return pathname.startsWith(path) ? (\n        <RouteComponent {...routeProps} />\n      ) : null;\n    }\n  }\n}\n\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Route渲染的三种方式`}</strong></p>\n    <p>{`除了component外，还有两种不太常用但也很好用的渲染组件方式:childre和render。\n至于其内部如何实现，以及动态路由参数的实现，在文末源码会有体现，这里就不再贴代码了。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n<Switch>\n    <Route exact path=\"/\"> <Home /></Route>\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/dashboard\" children={<Dashboard />} />\n    <Route path=\"/news\" render={()=><News />} />\n    <Route path=\"/games\" component={()=><Games/>} />\n</Switch>\n\n`}</code></pre>\n    <p>{`接下来就是一些小东西了，基本上看代码就能懂大概思路。`}</p>\n    <h2>{`Link`}</h2>\n    <p>{`Link 本质是a标签,只不过跳转方式变成了点击执行push方法,其本质是改变hash。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n class Link extends React.Component {\n  static contextType = RouterContext;\n\n  render() {\n    return (\n      <a\n        href={\n          \"#\" +\n          (typeof this.props.to === \"object\"\n            ? this.props.to.pathname\n            : this.props.to)\n        }\n        onClick={() => {\n          this.context.history.push(this.props.to);\n        }}\n      >\n        {this.props.children}\n      </a>\n    );\n  }\n}\n\n\n`}</code></pre>\n    <h2>{`NavLink`}</h2>\n    <p>{`NavLink 本质上是对Link的一个加强,在匹配上对应的路由后添加一个active类名，可使用css自定义样式。\n其他方面，使用方式和传参都和Link一样。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n//判断地址栏路径和to里的路径是否一致,一致则添加active类名\nlet NavLink = (props: Props) => {\n  let { to, exact, children } = props;\n\n  return (\n    <Route\n      path={to}\n      exact={exact}\n      children={(childrenProps) => {\n        return (\n          <Link\n            className={childrenProps.match ? \"active\" : \"\"}\n            to={to}\n            {...childrenProps}\n          >\n            {children}\n          </Link>\n        );\n      }}\n    />\n  );\n};\n\n\n`}</code></pre>\n    <h2>{`Switch`}</h2>\n    <p>{`Switch 包裹的组件只会匹配第一个,不会重复匹配`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n class Switch extends React.Component {\n  static contextType = RouterContext;\n\n\n  render() {\n    //从context获取的路径与子组件进行匹配\n    let pathname = this.context.location.pathname;\n    if (!this.props.children) return null;\n\n    let children;\n\n    children = Array.isArray(this.props.children)\n      ? this.props.children\n      : [this.props.children];\n\n    //此处不用forEach是因为它无法中途return\n    for (let i = 0; i < children.length; i++) {\n      let child = children[i];\n      const { path = \"/\", exact = false } = child.props;\n      let paramsName = [];\n      let regexp = pathToRegexp(path, paramsName, { end: exact });\n      let res = pathname.match(regexp);\n      //一旦匹配到后续就不再匹配\n      if (res) return child;\n    }\n\n    return null;\n  }\n}\n\n\n`}</code></pre>\n    <h2>{`Redirect`}</h2>\n    <p>{`如果所有路径都没匹配,会跳转到Redirect to 指定的页面。\n这个一般放在Switch内部最后位置，用于兜底。\n此外，Redirect也可以结合权限路由使。比如登录验证，不符合预期就重定向到登录页。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{` class Redirect extends React.Component {\n  static contextType = RouterContext;\n  render() {\n    this.context.history.push(this.props.to);\n    return null;\n  }\n}\n\n\n`}</code></pre>\n    <h2>{`权限路由`}</h2>\n    <p>{`渲染对应路径的组件前先判断是否有权限，有则渲染,否则重定向到指定页面。`}</p>\n    <p>{`权限路由=Route+自定义逻辑。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n  let Protected = (props: Props) => {\n  let { path, component: RouteComponent } = props;\n\n  return (\n    <Route\n      path={path}\n      render={(renderProp) => {\n        if (window.localStorage.getItem(\"auth\") === \"success\") {\n          return <RouteComponent {...props} {...renderProps} />;\n        } else {\n          return <Redirect to=\"/\" />;\n        }\n      }}\n    />\n  );\n};\n\n`}</code></pre>\n    <h2>{`withRouter`}</h2>\n    <p>{`withRouter相比其他几个可能不太常用，但某些特定场景需要用到它。\n事实上，只有被容器包裹的Route才能从容器身上拿到上下文对象,从而获取history,location,match等属性。\n对于非路由渲染的组件(如APP组件)要想拿到这些属性，需要使用withRouter。`}</p>\n    <p>{`但仅仅如此也是不够的，真正数据来源还是在容器。只有容器才会通过context传递history,location,match等属性。\nwithRouter作为一个高阶组件,它会将上下文传递的属性交给被包裹的组件(App)。\n所以withRouter包裹的组件,必须放在路由容器里才会生效。`}</p>\n    <p><strong parentName=\"p\">{`容器包裹`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import {BrowserRouter} from 'react-router-dom'\nimport App from './App'\nconst el=<BrowserRouter><App/></BrowserRouter>\nrender(el,document.getElementById('root'))\n\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`WithRouter实现`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\n\nimport React, { ComponentType } from \"react\";\nimport { Route, RouteComponentProps } from \"./\";\n\nlet WithRouter = (Component) => {\n  //外层参数 如<App xxx={xxx}/>\n  return (props: any) => {\n    // 内层路由参数透传\n    return (\n      <Route\n        render={(routeProps: RouteComponentProps) => (\n          <Component {...routeProps} {...props} />\n        )}\n      />\n    );\n  };\n};\n\nexport default WithRouter;\n\n\n\n`}</code></pre>\n    <h2>{`阻止跳转`}</h2>\n    <p>{`阻止跳转的目的是对用户的误操作造成的非预期行为进行提示。\n比如填写了一半的表单,用户不小心点了其他链接,再回来表单被清空了，这就很难受。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`class Prompt extends React.Component{\n  static contextType = RouterContext;\n  render() {\n    const { when, message } = this.props;\n    if (when) {\n      this.context.history.block(message);\n    } else {\n      this.context.history.block(null);\n    }\n    return null;\n  }\n}\n\n\n`}</code></pre>\n    <p>{`其处理逻辑是对标志信息的收集,在点击Link时候，push方法执行,根据标志位进行弹窗提示。\n如果用户取消,则不跳转,反之,跳转。确切的说，这部分逻辑是放在了push方法中。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`//容器组件中\nlet contextVal= {\n  location: this.state.location,\n  history: {\n    push(to) {\n      if (this.message) {\n        let flag = window.confirm(\n          this.message(typeof to === \"object\" ? to.pathname : to)\n        );\n\n        if (!flag) return;\n      }\n      if (typeof to === \"object\") {\n        window.history.pushState(to.state, \"\", to.pathname);\n      } else {\n        window.history.pushState(null, \"\", to);\n      }\n    },\n    block(message) {\n      this.message = message;\n    },\n  },\n};\n\n\n`}</code></pre>\n    <p>{`为了便于理解，最后补一个小测试案例。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nfunction A(props) {\n  const [jump, setJump] = useState(false);\n  const [val, setVal] = useState(\"\");\n\n//如果输入框的值无效 就直接跳\n// 如果值有效  弹框提示\n  useEffect(() => {\n    if (val.length === 0) {\n      setJump(false);\n    } else {\n      setJump(true);\n    }\n  }, [val]);\n\n  return (\n    <div>\n      <Prompt\n        when={jump}\n        message={(location: string) => \\`Do you want to go \\${location}?\\`}\n      />\n      <form>\n        <input value={val} onChange={(e) => setVal(e.target.value)} />\n        <input type=\"submit\" value=\"按我\" />\n      </form>\n    </div>\n  );\n}\n\n\n`}</code></pre>\n    <h2>{`相关链接`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate\"\n        }}>{`https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate`}</a></li>\n    </ul>\n    <h2>{`源码压缩包`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/lengyuexin/code\"\n        }}>{`https://github.com/lengyuexin/code`}</a></li>\n    </ul>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动既殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}