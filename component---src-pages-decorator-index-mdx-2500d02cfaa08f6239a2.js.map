{"version":3,"sources":["webpack:///./src/pages/decorator/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"gRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,4BACA,uDACA,+DACA,sEACA,+DACA,0DACA,+BACA,sBACE,kBAAIC,WAAW,MAAf,UAA+B,0BAAYA,WAAW,MAAvB,8BAC/B,kBAAIA,WAAW,MAAf,YACA,kBAAIA,WAAW,MAAf,kBAAuC,0BAAYA,WAAW,MAAvB,gBACvC,kBAAIA,WAAW,MAAf,mBAAwC,0BAAYA,WAAW,MAAvB,eACxC,kBAAIA,WAAW,MAAf,mBAAwC,0BAAYA,WAAW,MAAvB,8BACxC,kBAAIA,WAAW,MAAf,gBAAqC,0BAAYA,WAAW,MAAvB,kBACrC,kBAAIA,WAAW,MAAf,kDACA,kBAAIA,WAAW,MAAf,6BAAkD,0BAAYA,WAAW,MAAvB,6CAClD,kBAAIA,WAAW,MAAf,QAA6B,0BAAYA,WAAW,MAAvB,eAE/B,sBACE,kBAAIA,WAAW,MAAf,wBACA,kBAAIA,WAAW,MAAf,2BACA,kBAAIA,WAAW,MAAf,0CACA,kBAAIA,WAAW,MAAf,oDAEF,8BACA,8BACA,uDACA,sDACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,uOAgBL,gCACA,uFACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,srBAsCL,mEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yhBA+BL,0CACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8HAaL,8BACA,4DACA,oDACA,iCACA,sBACE,kBAAIA,WAAW,MAAf,oBAAyC,0BAAYA,WAAW,MAAvB,yBACzC,kBAAIA,WAAW,MAAf,eAAoC,0BAAYA,WAAW,MAAvB,uCACpC,kBAAIA,WAAW,MAAf,wBAEF,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,iTAmBL,iBAAQ,CACN,MAAS,GAET,kBAAIA,WAAW,MAAf,QAA6B,0BAAYA,WAAW,MAAvB,cAC7B,kBAAIA,WAAW,MAAf,WAAgC,+BAAGA,WAAW,MAAS,CACnD,KAAQ,0BADoB,yBAAhC,YAIF,8BACA,iDACA,gDACA,+BACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kXAwBL,8BACA,8EACA,6DACA,qEACA,qBAAG,sBAAQA,WAAW,KAAnB,oBACH,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wkCAyCL,qBAAG,sBAAQA,WAAW,KAAnB,eACH,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qpBA+BL,qBAAG,sBAAQA,WAAW,KAAnB,oBACH,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,sQAgBL,8BACA,4DACA,uEACA,sBACE,kBAAIA,WAAW,MAAf,UAA+B,0BAAYA,WAAW,MAAvB,eAC/B,kBAAIA,WAAW,MAAf,wBAEF,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kkBAqBL,iBAAQ,CACN,MAAS,GAET,kBAAIA,WAAW,MAAf,aAEF,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wZAkBL,iBAAQ,CACN,MAAS,GAET,kBAAIA,WAAW,MAAf,wCACA,kBAAIA,WAAW,MAAf,iBAEF,8BACA,qBAAG,+BAAGA,WAAW,KAAQ,CACrB,KAAQ,+DADT,cAGH,4BACA,gCACA,gCACA,yCACA,qCAKJJ,EAAWK,gBAAiB","file":"component---src-pages-decorator-index-mdx-2500d02cfaa08f6239a2.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/bytedance/Desktop/gatsby/src/components/BlogLayout/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2>{`前言`}</h2>\n    <p>{`装饰器可对指定的类/类方法/属性/参数进行装饰,扩展其功能。`}</p>\n    <p>{`它本质是一个函数,底层实现上依赖Object.defineProperty。`}</p>\n    <p>{`逐步发展至今,装饰器不再只是简化代码的语法糖,还可作为某些特定场景的解决方案(比如鉴权)。`}</p>\n    <p>{`保持装饰器的单一职责,通过灵活组合,可以让代码更为简洁明了,让开发更为高效。`}</p>\n    <p>{`下面以一个ts项目为例,介绍下常用类型装饰器的基本使用和业务场景。`}</p>\n    <h2>{`项目初始化`}</h2>\n    <ol>\n      <li parentName=\"ol\">{`全局安装ts `}<inlineCode parentName=\"li\">{`npm install -g typescript`}</inlineCode></li>\n      <li parentName=\"ol\">{`新建文件夹并进入`}</li>\n      <li parentName=\"ol\">{`生成package.json `}<inlineCode parentName=\"li\">{`npm init -y`}</inlineCode></li>\n      <li parentName=\"ol\">{`生成tsconfig.json `}<inlineCode parentName=\"li\">{`tsc --init`}</inlineCode></li>\n      <li parentName=\"ol\">{`项目中安装ts和ts-node `}<inlineCode parentName=\"li\">{`npm i typescript ts-node `}</inlineCode></li>\n      <li parentName=\"ol\">{`项目中安装nodemon `}<inlineCode parentName=\"li\">{`npm i nodemon`}</inlineCode></li>\n      <li parentName=\"ol\">{`tsconfig中设置experimentalDecorators为true,添加装饰器支持`}</li>\n      <li parentName=\"ol\">{`package.json中添加运行脚本 start:`}<inlineCode parentName=\"li\">{`nodemon  -e  ts  --exec ts-node  src/app`}</inlineCode></li>\n      <li parentName=\"ol\">{`启动项目 `}<inlineCode parentName=\"li\">{`npm start`}</inlineCode></li>\n    </ol>\n    <ul>\n      <li parentName=\"ul\">{`ts-node将ts编译成js文件并执行`}</li>\n      <li parentName=\"ul\">{`nodemon检测到目标文件发生更改后自动重启`}</li>\n      <li parentName=\"ul\">{`nodemon -e 表示添加支持的文件扩展, --exec表示执行指定命令`}</li>\n      <li parentName=\"ul\">{`如果觉得隐式any 很不爽,可以在tsconfig中设置noImplicitAny为false`}</li>\n    </ul>\n    <h2>{`基本使用`}</h2>\n    <h3>{`类装饰器`}</h3>\n    <p>{`类装饰器作用在指定类上,target拿到的就是类的构造函数。`}</p>\n    <p>{`拿到target后可以做很多事,比如增加额外的方法和属性。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\nconst logName: ClassDecorator = target => {\n  // 反射api,形如target[prop]\n  // 下文还会用到反射\n  // npm上的 reflect-metadata也可以看看\n  const name = Reflect.get(target, 'name');\n  console.log(name);\n};\n\n@logName \nclass User {}\n\n\n`}</code></pre>\n    <h3>{`类方法装饰器`}</h3>\n    <p>{`类方法装饰器作用在类的方法上,有三个参数,分别是类的构造函数(静态方法)或者原型对象(实例方法),属性名和该属性的描述对象。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const check: MethodDecorator = (target, key, descriptor: PropertyDescriptor) => {\n // 缓存旧函数,实际上就是装饰器作用的目标对象\n // 这里指的是say方法\n const fn = descriptor.value;\n // 重写该方法,自定义一些逻辑\n // 装饰要保留原有功能,所以最后要调用之前的旧方法\n  descriptor.value = function () {\n    if (target.constructor.name !== 'User') {\n      console.error('method say must called by class User');\n      return;\n    }\n    fn.call(this);\n  };\n // 返回属性描述对象\n  return descriptor;\n};\n\n\nclass User {\n  @check // 使用类方法装饰器\n  say() {\n    console.log('hi~');\n  }\n}\n\nclass Cat {\n  @check // 使用类方法装饰器\n  say() {\n    console.log('hi~');\n  }\n}\n\nnew User().say();// hi~\nnew Cat().say();// method say must called by class User\n\n`}</code></pre>\n    <p>{`上述使用的装饰器都是不接收参数的。如果需要接收参数,就再包装一层函数(利用了闭包)。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\n// auth是一个简单的权限装饰器,限定某方法只有管理员可执行\nconst auth =\n  (isAdmin = false) =>\n    (target, key, descriptor: PropertyDescriptor) => {\n      const fn = descriptor.value;\n      descriptor.value = function () {\n        if (!isAdmin) {\n          console.error('no auth');\n          return;\n        }\n        fn.call(this);\n      };\n\n      return descriptor;\n    };\n\nclass User {\n  @auth(true) // auth方法调用,返回一个类方法装饰器\n  edit() {\n    console.log('edit');\n  }\n}\n\n// auth入参为真值,打印 edit\n// 反之,打印 no auth\nnew User().edit();\n\n`}</code></pre>\n    <p>{`多个装饰器可以作用同一个目标对象.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\nclass UserCtrl {\n\n  @auth(['admin'])// 鉴权\n  @get('/api/user/list') // 设置请求方法\n  listUser(){\n    // xxx\n  }\n \n}\n`}</code></pre>\n    <h2>{`业务场景`}</h2>\n    <p>{`一个比较经典的场景是借助反射和装饰器实现server端路由的自动装载。`}</p>\n    <p>{`下面以一个koa项目为例,介绍下这部分功能的具体实现。`}</p>\n    <h3>{`koa环境搭建`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`安装koa和koa-router `}<inlineCode parentName=\"li\">{`npm i koa koa-router`}</inlineCode></li>\n      <li parentName=\"ol\">{`安装koa相关类型声明 `}<inlineCode parentName=\"li\">{`npm i @types/koa @types/koa-router`}</inlineCode></li>\n      <li parentName=\"ol\">{`根目录src/app.js写入如下代码`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\nimport Koa from 'koa';\nimport Router from 'koa-router';\n\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(3000, () => {\n  console.log('run server...');\n});\n\n`}</code></pre>\n    <ol {...{\n      \"start\": 5\n    }}>\n      <li parentName=\"ol\">{`启动项目 `}<inlineCode parentName=\"li\">{`npm start`}</inlineCode></li>\n      <li parentName=\"ol\">{`可以浏览器打开 `}<a parentName=\"li\" {...{\n          \"href\": \"http://localhost:3000\"\n        }}>{`http://localhost:3000`}</a>{` 端口测试一下`}</li>\n    </ol>\n    <h3>{`预期效果`}</h3>\n    <p>{`上边的代码还没有做有优化,业务逻辑都耦合在一起。`}</p>\n    <p>{`我们需要一个更为清晰,更可维护的代码组织方式。`}</p>\n    <p>{`向下面这样:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\n@controller('/main')\nexport default class MainCtrl {\n  @get('/index')\n  async index(ctx) {\n    ctx.body = 'hello world';\n  }\n  @get('/home')\n  async home(ctx) {\n    ctx.body = 'hello home';\n  }\n}\n\n// 我们希望上述代码等价于如下写法\n\nrouter.get('/main/index',ctx=>{\n   ctx.body = 'hello world';\n})\nrouter.get('/main/home',ctx=>{\n   ctx.body = 'hello home';\n})\n`}</code></pre>\n    <h3>{`实现思路`}</h3>\n    <p>{`我们的最终目标是拼出controller中包含的路由信息并完成注册,这其实是一个数据set和get的过程。`}</p>\n    <p>{`通过装饰器在相应controller的原型对象上设置请求前缀和路由信息。`}</p>\n    <p>{`然后遍历所有controller并实例化,借助反射获取到原型上存储的数据,完成路由注册。`}</p>\n    <p><strong parentName=\"p\">{`装饰器decorator.ts`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export const controller =\n  (prefix = ''): ClassDecorator =>\n    (target: any) => {\n      target.prototype.prefix = prefix;\n    };\n\ntype Method = 'get' | 'post' | 'delete' | 'options' | 'put' | 'head';\n\nexport interface RouteDefinition {\n  path: string;\n  requestMethod: Method;\n  methodName: string;\n}\n\nconst creatorFactory =\n  (requestMethod: Method) =>\n    (path: string): MethodDecorator =>\n      (target, name) => {\n        if (!Reflect.has(target.constructor, 'routes')) {\n          Reflect.defineProperty(target.constructor, 'routes', {\n            value: [],\n          });\n        }\n        const routes = Reflect.get(target.constructor, 'routes');\n        routes.push({\n          requestMethod,\n          path,\n          methodName: name,\n        });\n      };\n\nexport const get = creatorFactory('get');\n// export const post = creatorFactory('post');\n// export const del = creatorFactory('delete');\n// export const put = creatorFactory('put');\n// export const options = creatorFactory('options');\n// export const head = creatorFactory('head');\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`注册路由app.ts`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import Koa from 'koa';\nimport Router from 'koa-router';\nimport MainCtrl from './main-ctrl';\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\n\n[MainCtrl].forEach(controller => {\n  const instance: any = new controller();\n  const { prefix } = instance;\n  const routes = Reflect.get(controller, 'routes');\n  routes.forEach(route => {\n    router[route.requestMethod](prefix + route.path, ctx => {\n      instance[route.methodName](ctx);\n    });\n  });\n});\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(3000, () => {\n  console.log('run server...');\n});\n\n\n`}</code></pre>\n    <p><strong parentName=\"p\">{`控制器main-ctrl.ts`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { controller, get } from './decorator';\n@controller('/main')\nexport default class MainCtrl {\n  @get('/index')\n  async index(ctx) {\n    ctx.body = 'hello world';\n  }\n  @get('/home')\n  async home(ctx) {\n    ctx.body = 'hello home';\n  }\n}\n\n`}</code></pre>\n    <h3>{`自动扫描`}</h3>\n    <p>{`上述实现还存在一个弊端,如果控制器特别多,每次都需要手动导入,很麻烦。`}</p>\n    <p>{`一种更优雅的方式是批量扫描,使用glob扫描指定的控制器目录(比如controllers)。`}</p>\n    <ol>\n      <li parentName=\"ol\">{`安装glob `}<inlineCode parentName=\"li\">{`npm i glob`}</inlineCode></li>\n      <li parentName=\"ol\">{`根目录新建load.ts,写入如下代码`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import * as glob from 'glob';\nimport path from 'path';\nexport default (folder: string, router: any) => {\n  // 扫描指定文件夹下所有ts文件\n  glob.sync(path.join(folder, '**/*.ts')).forEach(item => {\n    // 加载controller\n    const controller = require(item).default;\n    // 实例化\n    const instance: any = new controller();\n    const { prefix } = instance;\n    const routes = Reflect.get(controller, 'routes');\n    routes.forEach(route => {\n      router[route.requestMethod](prefix + route.path, ctx => {\n        instance[route.methodName](ctx);\n      });\n    });\n  });\n};\n`}</code></pre>\n    <ol {...{\n      \"start\": 3\n    }}>\n      <li parentName=\"ol\">{`修改app.ts`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import Koa from 'koa';\nimport Router from 'koa-router';\nimport path from 'path';\nimport load from './load';\nconst app = new Koa();\nconst router = new Router();\nrouter.get('/', ctx => {\n  ctx.body = 'hello';\n});\nload(path.resolve(__dirname, './controllers'), router);\napp.use(router.routes());\napp.use(router.allowedMethods());\napp.listen(3000, () => {\n  console.log('run server...');\n});\n`}</code></pre>\n    <ol {...{\n      \"start\": 4\n    }}>\n      <li parentName=\"ol\">{`将之前的main-ctrl.ts移动到新建的controllers目录中`}</li>\n      <li parentName=\"ol\">{`浏览器访问对应路径,测试`}</li>\n    </ol>\n    <h2>{`源码地址`}</h2>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://github.com/lengyuexin/code/blob/main/ts-server.zip\"\n      }}>{`decorator`}</a></p>\n    <h2>{`再会`}</h2>\n    <p>{`情如风雪无常,`}</p>\n    <p>{`却是一动即殇。`}</p>\n    <p>{`感谢你这么好看还来阅读我的文章,`}</p>\n    <p>{`我是冷月心,下期再见。`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}