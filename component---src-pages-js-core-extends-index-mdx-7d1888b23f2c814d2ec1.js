(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{BiVN:function(e,n,t){},EsZP:function(e,n,t){},Hv6d:function(e,n,t){"use strict";var a=t("KPh1"),r=t("qRUh"),c=t("xwgP"),s=t.n(c),o=t("Wbzz"),l=t("d33t"),u=t.n(l),i=(t("vPK/"),t("Zttt")),p=t("EYWl"),b=t("JLKy"),y=t("k7Sn"),g=function(e){return y.supportedLanguages[e].replace(/ /g," ")},m=function(e){function n(){return e.apply(this,arguments)||this}return Object(r.a)(n,e),n.prototype.render=function(){var e=this.props,n=e.translations,t=e.lang,a=e.languageLink,r=e.editUrl;return s.a.createElement("div",{className:"translations"},s.a.createElement(b.a,{style:{fontFamily:'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",\n    "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans",\n    "Droid Sans", "Helvetica Neue", sans-serif'}},n.length>0&&s.a.createElement(s.a.Fragment,null,s.a.createElement("span",null,"Translated by readers into: "),n.map((function(e,r){return s.a.createElement(s.a.Fragment,{key:e},e===t?s.a.createElement("b",null,g(e)):s.a.createElement(o.Link,{to:a(e)},g(e)),r===n.length-1?"":" • ")}))),"zh-hans"!==t&&s.a.createElement(s.a.Fragment,null,s.a.createElement("br",null),s.a.createElement("br",null),s.a.createElement(o.Link,{to:a("zh-hans")},"Read the original")," • ",s.a.createElement("a",{href:r,target:"_blank",rel:"noopener noreferrer"},"Improve this translation")," • ",s.a.createElement(o.Link,{to:"/"+t},"View all translated posts")," ")))},n}(s.a.Component),d=t("L6NH"),f=t("p3AD");function h(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function O(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?h(Object(t),!0).forEach((function(n){Object(a.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):h(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var j=function(e){function n(){return e.apply(this,arguments)||this}return Object(r.a)(n,e),n.prototype.render=function(){console.log(this.props);var e=this.props,n=e.pageContext,a=e.children,r=e.location,c=e.previous,l=e.next,b=e.translations,y=u()(this.props,"queryData.site.siteMetadata.title"),h=n.langKey,j=n.slug;b&&(b=b.slice()).sort((function(e,n){return g(e)<g(n)?-1:1})),function(e){switch(e){case"ru":case"bg":t("EsZP"),t("s85H");break;case"uk":t("EsZP"),t("s85H"),t("Mq6Z"),t("e/YJ");break;case"cs":case"da":case"de":case"es":case"fi":case"fr":case"he":case"hu":case"it":case"nl":case"no":case"pl":case"pt-br":case"sk":case"sr":case"sq":case"sv":case"tr":t("Mq6Z"),t("e/YJ");break;case"vi":t("Vjog"),t("Pf5Y");break;case"fa":t("BiVN");break;case"ar":t("xpFW")}}(h);var T=function(e,n){var t=e.replace(n+"/","");return function(e){return"zh-hans"===e?t:""+e+t}}(j,h),S=T("en"),k="https://github.com/gaearon/overreacted.io/edit/master/src/pages/"+S.slice(1,S.length-1)+"/index"+("zh-hans"===h?"":"."+h)+".md";return s.a.createElement(i.a,{location:r,title:y},s.a.createElement(p.a,{lang:h,title:n.frontmatter.title,description:n.frontmatter.spoiler,slug:j,date:n.frontmatter.date}),s.a.createElement("div",{style:{marginLeft:"auto",marginRight:"auto",maxWidth:Object(f.a)(24)}},s.a.createElement("article",null,s.a.createElement("header",null,s.a.createElement("h1",{style:{color:"var(--textTitle)"}},n.frontmatter.title),s.a.createElement("p",{style:O(O({},Object(f.b)(-.2)),{},{display:"block",marginBottom:Object(f.a)(1),marginTop:Object(f.a)(-.8)})},Object(d.a)(n.frontmatter.date,h)),b&&b.length>0&&s.a.createElement(m,{translations:b,editUrl:k,languageLink:T,lang:h})),s.a.createElement("div",null,a)),s.a.createElement("aside",null,s.a.createElement("nav",null,s.a.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},s.a.createElement("li",null,c&&s.a.createElement(o.Link,{to:c.fields.slug,rel:"prev",style:{marginRight:20}},"← ",c.frontmatter.title)),s.a.createElement("li",null,l&&s.a.createElement(o.Link,{to:l.fields.slug,rel:"next"},l.frontmatter.title," →")))))))},n}(s.a.Component);n.a=function(e){return s.a.createElement(o.StaticQuery,{query:"2199005656",render:function(n){return s.a.createElement(j,Object.assign({queryData:n},e))}})}},Mq6Z:function(e,n,t){},NqqT:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return o})),t.d(n,"default",(function(){return i}));var a=t("shca"),r=(t("xwgP"),t("N0F1")),c=t("Hv6d"),s=t("JLKy"),o={},l={_frontmatter:o},u=c.a;function i(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(u,Object.assign({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h3",null,"原型链继承"),Object(r.b)(s.a,{mdxType:"P"},"原型中包含的引用值会在所有实例间共享，所以属性通常会在构造函数中定义而不会定义在原型上。 在使用原型实现继承时，原型实际上变成了另一个类型的实例。 这意味着原先的实例属性摇身一变成为了原型属性。"),Object(r.b)(s.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType() {\n    this.colors = ["red", "blue", "green"];\n}\nfunction SubType() { }\n// 继承 SuperType\nSubType.prototype = new SuperType();\nlet instance1 = new SubType();\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nlet instance2 = new SubType();\nconsole.log(instance2.colors); // "red,blue,green,black"\n\n\n'))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"存在的问题")),Object(r.b)(s.a,{style:{background:"lightblue"},mdxType:"P"},"引用共享:在这个例子中,SuperType构造函数定义了一个colors属性，其中包含一个数组(引用值)。 每个SuperType的实例都会有自己的colors属性，包含自己的数组。 但是，当SubType通过原型继承SuperType后,SubType.prototype变成了SuperType的一个实例，因而也获得了自己的colors属性。 这类似于创建了SubType.prototype.colors属性。 最终结果是,SubType的所有实例都会共享这个colors属性。 这一点通过instance1.colors上的修改也能反映到instance2.colors上就可以看出来。"),Object(r.b)(s.a,{style:{background:"#4AC29A"},mdxType:"P"},"无法在子类构造函数中向父类构造函数传参"),Object(r.b)("h3",null,"构造函数继承"),Object(r.b)(s.a,{style:{background:"pink"},mdxType:"P"},"目的：为了解决原型链继承存在的两个问题，出现了构造函数继承",Object(r.b)("br",null),"思路：在子类构造函数中调用父类构造函数,各自绑定上下文，无干扰"),Object(r.b)(s.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType(name) {\n    this.colors = ["red", "blue", "green"];\n    this.name=name\n}\n\n//不写在构造函数中的属性，构造函数继承是获取不到的\nSuperType.prototype.age=18\n//不写在构造函数中的方法，构造函数继承是获取不到的\nSuperType.prototype.say=function(){\n    console.log(\'say super\')\n}\n\nfunction SubType() {\n    // 使用构造函数继承 SuperType\n    SuperType.call(this,\'tom\');\n}\nvar instance1 = new SubType();\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // "red,blue,green"\nconsole.log(instance2.name); // "tom"\nconsole.log(instance2.say); // undefined\nconsole.log(instance2.age); // undefined\n\n'))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"存在问题")),Object(r.b)(s.a,{style:{background:"lightblue"},mdxType:"P"},"必须在构造函数中定义属性和方法，导致函数不能重用",Object(r.b)("br",null),"子类不能访问父类原型上定义的属性和方法"),Object(r.b)("h3",null,"组合继承"),Object(r.b)(s.a,{mdxType:"P"},"原型链继承和构造函数继承是刚好互补的。组合继承就是将原型链和构造函数两者的优点集中了起来。 思路是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性。 这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。"),Object(r.b)(s.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'function SuperType(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    // 继承属性\n    SuperType.call(this, name); //父类构造函数被执行\n    this.age = age;\n}\n// 继承方法  子类构造器未修正\nSubType.prototype = new SuperType(); //父类构造函数被执行\n\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\nvar instance1 = new SubType("Nicholas", 29);\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\ninstance1.sayName(); // "Nicholas";\ninstance1.sayAge(); // 29\nvar instance2 = new SubType("Greg", 27);\nconsole.log(instance2.colors); // "red,blue,green"\ninstance2.sayName(); // "Greg";\ninstance2.sayAge(); // 27\n'))),Object(r.b)(s.a,{style:{background:"pink"},mdxType:"P"},"组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。 而且组合继承也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力。 看似完美，却并不完美。父类构造函数被执行两次，子类构造器未修正。"),Object(r.b)("h3",null,"寄生组合式继承 (最优继承)"),Object(r.b)(s.a,{style:{background:"lightblue"},mdxType:"P"},"寄生式组合继承通过构造函数继承属性，但使用混合式原型链继承方法。 基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。 说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。"),Object(r.b)(s.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n//取得父类原型的一个副本 \nSubType.prototype=Object.create(SuperType.prototype)\n//无副作用的修正构造器指向\n//原型继承修正会导致一变皆变\nSubType.prototype.constructor=SubType \nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\n'))),Object(r.b)("h3",null,"extends关键字"),Object(r.b)(s.a,{style:{background:"#FDB99B"},mdxType:"P"},Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function A(){\n    //相当于super\n    B.call(this,18)\n    _extends(A, B)//extends\n}\nfunction B(age){\n    this.age=age\n}\n\nfunction _extends(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\n"))))}i.isMDXComponent=!0},Pf5Y:function(e,n,t){},Vjog:function(e,n,t){},"e/YJ":function(e,n,t){},k7Sn:function(e,n){n.supportedLanguages={en:"English","zh-hans":"简体中文"}},s85H:function(e,n,t){},shca:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}t.d(n,"a",(function(){return a}))},"vPK/":function(e,n,t){},xpFW:function(e,n,t){}}]);
//# sourceMappingURL=component---src-pages-js-core-extends-index-mdx-7d1888b23f2c814d2ec1.js.map