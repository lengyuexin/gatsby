{"version":3,"sources":["webpack:///./src/pages/js-core/promise/index.mdx","webpack:///./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","style","background","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"wPASaA,EAAe,GACtBC,EAAc,CAClBD,gBAEIE,EAAYC,UACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,8BACA,qBAAG,+BAAGC,WAAW,KAAQ,CACrB,KAAQ,+CADT,+CAGH,sCACA,YAAC,IAAD,CAAGC,MAAO,CACRC,WAAY,WACXH,QAAQ,KACT,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,ujDAkEP,yCACA,YAAC,IAAD,CAAGD,QAAQ,KAAX,4CAGA,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,mKAWL,wCACA,YAAC,IAAD,CAAGD,QAAQ,KAAX,mCAGA,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,wIAUL,qCACA,YAAC,IAAD,CAAGD,QAAQ,KAAX,mBACY,uBADZ,uBAEgB,uBAFhB,iCAG0B,uBAH1B,uBAIgB,uBAJhB,+BAOA,YAAC,IAAD,CAAGE,MAAO,CACRC,WAAY,WACXH,QAAQ,KACT,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,6gBA0BP,sCACA,YAAC,IAAD,CAAGD,QAAQ,KAAX,mBACY,uBADZ,uBAEgB,uBAFhB,+BAGwB,uBAHxB,4CAMA,YAAC,IAAD,CAAGE,MAAO,CACRC,WAAY,WACXH,QAAQ,KACT,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,wbAqBP,+BACA,YAAC,IAAD,CAAGD,QAAQ,KAAX,uEACgE,uBADhE,kBAIA,YAAC,IAAD,CAAGE,MAAO,CACRC,WAAY,WACXH,QAAQ,KACT,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,4FAWXJ,EAAWO,gBAAiB,G,kCCpNb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIE,EAAKC,EAFLC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,GAG7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAGvB,OAAOE,EAZT","file":"component---src-pages-js-core-promise-index-mdx-8bd50328378dd646371c.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"C:/Users/lengy/Desktop/gatsby-blog/src/components/BlogLayout/index.js\";\nimport P from '../../../components/Panel.js';\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h3>{`推荐阅读`}</h3>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://juejin.cn/post/6844904116913700877\"\n      }}>{`https://juejin.cn/post/6844904116913700877`}</a></p>\n    <h3>{`Promise(简化版)`}</h3>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`// 先定义三个常量表示状态\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction MyPromise(fn) {\n    this.status = PENDING;    // 初始状态为pending\n    this.value = null;        // 初始化value\n    this.reason = null;       // 初始化reason\n\n    // 构造函数里面添加两个数组存储成功和失败的回调\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    // resolve方法参数是value\n    resolve = (value) => {\n        if (this.status === PENDING) {\n            this.status = FULFILLED;\n            this.value = value;\n            // resolve里面将所有成功的回调拿出来执行\n            this.onFulfilledCallbacks.forEach(callback => {\n                callback(this.value);\n            });\n        }\n    }\n\n    // reject方法参数是reason\n    reject = (reason) => {\n        if (this.status === PENDING) {\n            this.status = REJECTED;\n            this.reason = reason;\n            // resolve里面将所有失败的回调拿出来执行\n            this.onRejectedCallbacks.forEach(callback => {\n                callback(this.reason);\n            });\n        }\n    }\n\n    try {\n        fn(resolve, reject);\n    } catch (error) {\n        reject(error);\n    }\n}\n\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n        onFulfilled(this.value)\n    }\n    if (this.status === REJECTED) {\n        onRejected(this.reason);\n    }\n    // 如果还是PENDING状态，将回调保存下来\n    if (this.status === PENDING) {\n        this.onFulfilledCallbacks.push(onFulfilled);\n        this.onRejectedCallbacks.push(onRejected);\n    }\n    return this\n}\n\n\n\n`}</code></pre>\n    </P>\n    <h3>{`Promise.resolve`}</h3>\n    <P mdxType=\"P\">\n如果是Promise的实例,就直接返回。如果不是则用Promise包裹一下后返回\n    </P>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nPromise.resolve = function (p) {\n    if (p instanceof Promise)  return p;\n    return new Promise(function (resolve) {\n        resolve(p);\n    });\n}\n\n`}</code></pre>\n    <h3>{`Promise.reject`}</h3>\n    <P mdxType=\"P\">\n返回一个新的Promise实例，该实例的状态为rejected\n    </P>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\nPromise.reject = function (reason) {\n    return new Promise(function (resolve,reject) {\n        reject(reason);\n    });\n}\n\n`}</code></pre>\n    <h3>{`Promise.all`}</h3>\n    <P mdxType=\"P\">\n接收一个包含promsie的数组<br />\n不是promise的会转为promsie<br />\n必须等待所有的promise成功最后的结果才会resolve<br />\n其最终结果是一个数组,顺序与书写顺序一致<br />\n有一个失败则最终结果失败,返回第一个失败的reject\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`\nfunction all(promises=[]){\n    return new Promise((resolve,reject)=>{\n        let res=[]\n        let count=0;\n        let len=promises.length \n        if(len===0) return resolve(res)\n\n        promises.forEach((p,i)=>{\n            Promise.resolve(p).then((value)=>{\n                count++\n                res[i]=value \n                if(count===len){\n                    resolve(res)\n                }\n            },(reason)=>{\n                reject(reason)\n            })\n        })\n    })\n}\n\n`}</code></pre>\n    </P>\n    <h3>{`Promise.race`}</h3>\n    <P mdxType=\"P\">\n接收一个包含promsie的数组<br />\n不是promise的会转为promsie<br />\n不必等待所有的promise成功，最先完成的那个直接返回<br />\n一旦成功或失败不能转为其他状态，会立即结束，resolve和reject也会竞速\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`\nfunction race(promises = []) {\n    return new Promise((resolve, reject) => {\n        let len = promises.length\n        if (len === 0) return resolve()\n        for (let i = 0; i < len; i++) {\n            const p = promises[i];\n            Promise.resolve(p).then((value) => {\n                return resolve(value)\n            }, (reason) => {\n                return reject(reason)\n            })\n\n        }\n    })\n}\n\n`}</code></pre>\n    </P>\n    <h3>{`catch`}</h3>\n    <P mdxType=\"P\">\nPromise中的catch是.then(null, rejection)或.then(undefined, rejection)的别名<br />\n用于指定发生错误时的回调函数\n    </P>\n    <P style={{\n      background: '#FDB99B'\n    }} mdxType=\"P\">\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`Promise.prototype.catch = function(onRejected) {\n  this.then(null, onRejected);\n}\n`}</code></pre>\n    </P>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}